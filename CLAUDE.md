# CLAUDE.md

Руководство для Claude Code при работе с кодовой базой проекта Savanna.

> Все дополнения в этот файл также оформляются через Я-декларации для единообразия и ясности.

## Архитектура проекта (критически важно)

### ECS архитектура с SOLID принципами

**Entity-Component-System с четким разделением ответственностей:**
- `World` использует **Composition Pattern**: EntityManager + ComponentManager + QueryManager + WorldState
- **Битовые маски** для быстрых запросов компонентов (O(1) проверка)
- **Structure of Arrays** для оптимальной производительности кэша
- **Специализированные интерфейсы** вместо монолитного ECSAccess (ISP)

**Принципы SOLID в архитектуре:**
- **SRP**: Каждый менеджер имеет единственную ответственность
- **OCP**: Новые типы животных добавляются через AnimalConfig без изменения систем
- **LSP**: Специализированные интерфейсы заменяемы на базовые типы
- **ISP**: Узкоспециализированные интерфейсы (HungerSystemAccess, MovementSystemAccess)
- **DIP**: Системы зависят от интерфейсов (VegetationProvider), не от конкретных реализаций

**Interface Segregation Principle (ISP) в действии:**
```go
// ❌ НЕПРАВИЛЬНО: Монолитный интерфейс принуждает систему знать о ненужных компонентах
type ECSAccess interface {
    // 30+ методов для ВСЕХ компонентов
    GetPosition(EntityID) (Position, bool)
    GetHealth(EntityID) (Health, bool)
    GetAnimation(EntityID) (Animation, bool)
    // ... ещё 27 методов
}

// ✅ ПРАВИЛЬНО: Узкоспециализированные интерфейсы
type HungerSystemAccess interface {
    GetHunger(EntityID) (Hunger, bool)
    SetHunger(EntityID, Hunger) bool
    ForEachWith(ComponentMask, QueryFunc)
    // Только необходимые методы
}
```

### Системы и порядок выполнения

Я СТРОГО соблюдаю порядок выполнения систем, так как от этого зависит корректность работы:

**GUI режим (cmd/game/game_world.go):**
```go
1. world.Update(deltaTime)                   // Обновление времени мира
2. animationManager.UpdateAnimalAnimations() // КРИТИЧЕСКИ: анимации ПЕРЕД системами!
3. systemManager.Update(world, deltaTime)    // Все игровые системы
```

**Порядок добавления систем (КРИТИЧЕСКИ ВАЖЕН):**
```go
systemManager.AddSystem(vegetationSystem)        // 1. Рост травы
systemManager.AddSystem(hungerSystemAdapter)     // 2. Управление голодом
systemManager.AddSystem(grassSearchAdapter)      // 3. Поиск травы и создание EatingState  
systemManager.AddSystem(grassEatingSystem)       // 4. Дискретное поедание травы
systemManager.AddSystem(behaviorSystemAdapter)   // 5. Поведение (проверяет EatingState)
systemManager.AddSystem(hungerSpeedAdapter)      // 6. Влияние голода на скорость
systemManager.AddSystem(movementSystemAdapter)   // 7. Движение (сбрасывает скорость едящих)
systemManager.AddSystem(combatSystem)            // 8. Бой и урон
systemManager.AddSystem(starvationAdapter)       // 9. Урон от голода
```

Нарушение этого порядка ЛОМАЕТ питание зайцев!

### Система питания зайцев - архитектура

Я понимаю что питание зайцев работает через ДВЕ отдельные системы:

**FeedingSystem (feeding.go):**
- Создаёт состояние поедания `EatingState{Target: 0}` 
- Запускается при голоде < 90% (`RabbitHungryThreshold`)
- Проверяет наличие травы >= 10 единиц (`MinGrassToFind`)
- НЕ даёт сытость - только создаёт состояние

**GrassEatingSystem (grass_eating_system.go):**
- Даёт сытость дискретно по кадрам анимации
- Питательность ТОЛЬКО при переходе кадра 0→1 анимации еды
- 2 единицы травы = 4 единицы сытости за кадр
- Прекращает поедание при достижении порога сытости

**Критическая логика дискретного питания:**
```go
// ПИТАТЕЛЬНОСТЬ ДАЕТСЯ ТОЛЬКО при переходе на кадр 1!
frameChangedTo1 := (prevFrame == 0 && currentFrame == 1)
if frameChangedTo1 {
    // Съедаем 2 единицы травы, даем 4 единицы сытости
    processGrassEatingTick()
}
```

### Анимационная система

Я понимаю что анимации КРИТИЧЕСКИ связаны с игровой логикой:

**Приоритеты анимаций зайца:**
```go
1. AnimDeathDying   // Если есть MaskCorpse
2. AnimEat          // Если есть MaskEatingState  
3. AnimRun/Walk/Idle // По скорости движения
```

**СТРОГОЕ ПРАВИЛО:** Анимация ATTACK не прерывается до завершения!

Анимации ДОЛЖНЫ обновляться ПЕРЕД системами в GUI режиме, иначе ломается синхронизация с дискретным питанием.

### Компоненты ECS для питания

Я использую следующие компоненты для системы питания:

- `Hunger{Value: float32}` - уровень голода 0-100%
- `EatingState{Target: EntityID, EatingProgress, NutritionGained}` - состояние поедания
- `Animation{CurrentAnim, Frame, Timer, Playing}` - для синхронизации с кадрами
- `Position` - для проверки наличия травы в тайле

**EatingState блокирует движение:**
```go
if world.HasComponent(entity, core.MaskEatingState) {
    world.SetVelocity(entity, core.Velocity{X: 0, Y: 0})
    return // Животное ест, не двигается
}
```

### Константы питания

Я использую ЕДИНСТВЕННЫЕ пороги голода для каждого типа животного:

```go
// animal_constants.go - ПРАВИЛЬНАЯ архитектура:
RabbitHungryThreshold = 90.0      // ЕДИНСТВЕННЫЙ порог для зайца
WolfHungerThreshold = 60.0        // ЕДИНСТВЕННЫЙ порог для волка
MaxHungerValue = 100.0            // Максимальная сытость (когда прекращает есть)

// Системы работают через компоненты Size, Speed, AnimalType, а НЕ через хардкоженные константы
// Заяц прекращает есть при достижении MaxHungerValue (100%), а не при отдельном пороге
```

### Принципы SOLID для констант

Я соблюдаю принципы SOLID при работе с константами:

**Single Responsibility Principle (SRP):** Каждая константа имеет одну ответственность
- `RabbitHungryThreshold` - ТОЛЬКО порог начала еды для зайца  
- `MaxHungerValue` - ТОЛЬКО максимальная сытость для ВСЕХ животных

**Open/Closed Principle (OCP):** Системы работают с компонентами, а не с конкретными типами
- ❌ НЕПРАВИЛЬНО: `if entity == rabbit then use RabbitSpeed`
- ✅ ПРАВИЛЬНО: `speed := world.GetSpeed(entity).Base`

**DRY принцип:** Нет дублирования констант
- ❌ УДАЛЕНО: `RabbitSatiatedThreshold` (дублировал `MaxHungerValue`)
- ✅ ЕДИНСТВЕННЫЙ источник истины для каждого параметра

### Критические точки разрушения

Я НЕ нарушаю следующие правила, иначе ломается питание:

1. **Порядок систем** - FeedingSystem ПЕРЕД GrassEatingSystem
2. **Порядок анимаций** - анимации ПЕРЕД системами в GUI
3. **Дискретность питания** - сытость ТОЛЬКО на кадре 1 анимации еды
4. **EatingState логика** - только одна система создаёт, одна удаляет
5. **Детерминированность** - headless ИДЕНТИЧЕН GUI режиму

Любое изменение в этих областях требует ПОЛНОГО тестирования питания зайцев!

### Архитектурные паттерны в проекте

**Strategy Pattern для поведения животных:**
```go
type BehaviorStrategy interface {
    UpdateBehavior(world core.BehaviorSystemAccess, entity core.EntityID, components AnimalComponents) core.Velocity
}

// HerbivoreBehaviorStrategy - стратегия травоядных
// PredatorBehaviorStrategy - стратегия хищников
```

**Builder Pattern для тестовых миров:**
```go
world, systemManager, entities := NewTestWorld().
    WithSmallSize().
    AddHungryRabbit().
    AddWolfNearRabbit(30.0, 50.0).
    Build()
```

**Adapter Pattern для интеграции систем:**
```go
// Адаптирует новые ISP интерфейсы к старому интерфейсу System
type HungerSystemAdapter struct {
    System *simulation.HungerSystem
}
```

**Facade Pattern для упрощения интерфейсов:**
```go
// GameWorld скрывает сложность управления системами и анимациями
type GameWorld struct {
    world            *core.World
    systemManager    *core.SystemManager
    animationManager *AnimationManager
}
```

**Factory Pattern для создания животных:**
```go
// CreateAnimalConfig создаёт конфигурацию по типу животного
func CreateAnimalConfig(animalType core.AnimalType) core.AnimalConfig

// CreateAnimal создаёт животное с правильными компонентами
func CreateAnimal(world *core.World, animalType core.AnimalType, x, y float32) core.EntityID
```

### Архитектура компонентной системы

**Компоненты как данные (Data-Oriented Design):**
- Компоненты содержат ТОЛЬКО данные, без логики
- Системы обрабатывают компоненты через универсальные интерфейсы
- Битовые маски для быстрой фильтрации сущностей

**Универсальная логика через компоненты:**
```go
// ❌ НЕПРАВИЛЬНО: Захардкоженные типы в системах
if animalType == TypeRabbit {
    speed = RabbitSpeed
}

// ✅ ПРАВИЛЬНО: Универсальная логика через компоненты
speed := world.GetSpeed(entity).Current
config := world.GetAnimalConfig(entity)
```

**Предопределённые наборы компонентов:**
```go
var (
    MovingEntities = NewComponentSet(MaskPosition, MaskVelocity)
    LivingEntities = NewComponentSet(MaskPosition, MaskHealth, MaskHunger, MaskAnimalType, MaskSize)
    AnimalsEntities = NewComponentSet(MaskPosition, MaskVelocity, MaskHealth, MaskHunger, 
                                     MaskAnimalType, MaskSize, MaskSpeed, MaskAnimalConfig)
)
```

### Управление константами и балансом

**Централизованное управление балансом в game_balance.go:**

1. **Базовые размеры** - единственные "магические" числа:
```go
const (
    RabbitBaseRadius = 16.0 // Заяц - небольшое травоядное
    WolfBaseRadius   = 24.0 // Волк - крупный хищник
)
```

2. **Выводимые константы через множители:**
```go
const (
    RabbitVisionMultiplier  = 6.25 // 100.0 / 16.0 = 6.25x от размера
    WolfAttackRangeMultiplier = 1.2 // Атака дальше своего размера
)
```

3. **Универсальные множители для всех животных:**
```go
const (
    SearchSpeedMultiplier    = 0.8 // Поиск еды/добычи
    WanderingSpeedMultiplier = 0.7 // Случайное блуждание
    ContentSpeedMultiplier   = 0.3 // Спокойное состояние
)
```

**Принцип DRY для констант:**
- animal_constants.go содержит только алиасы для обратной совместимости
- Все реальные константы ТОЛЬКО в game_balance.go
- Автоматическая проверка магических чисел через golangci-lint

### Тестовая архитектура и TDD

**Test-Driven Debug процесс:**
1. Пользователь сообщает о проблеме в реальной игре
2. Создаю тест который воспроизводит ТОЧНО ТАКУЮ ЖЕ среду
3. Убеждаюсь что тест ПАДАЕТ и показывает проблему
4. Исправляю код чтобы тест проходил
5. Запускаю все связанные тесты для проверки регрессий

**Строгое правило:** Если пользователь говорит что функционал не работает, а тесты проходят - значит тест написан неправильно!

**Builder Pattern для устранения дублирования в тестах:**
```go
// Вместо 50+ строк дублированного кода в каждом тесте
world, systemManager, entities := NewTestWorld().
    WithLargeSize().                    // E2E тест
    AddHungryRabbit().                 // Стандартная позиция
    AddWolfNearRabbit(25.0, 40.0).    // На расстоянии атаки
    Build()
```

**Специализированные системы тестирования:**
```go
// CreateTestSystemManager - полный набор для интеграционных тестов
// CreateMinimalSystemManager - только основные системы
// CreateCombatSystemManager - только боевые системы
// CreateMockVegetationSystem - заглушка для unit тестов
```

### Детерминированность и единообразие режимов

**Строгое правило:** Headless режим ИДЕНТИЧЕН GUI режиму во всём, кроме отсутствия окна на экране.

**Детерминированность обеспечивается:**
- Фиксированный timestep (1/60 секунды)
- Единый RNG через world.GetRNG() для всей игровой логики
- Отсутствие time.Now() в симуляции
- Стабильная сортировка вместо итерации по map
- Отсутствие горутин в игровой логике

**Headless режим содержит ВСЁ:**
- Анимационные системы (animation.NewAnimationSystem())
- Загрузку спрайтов и графических ресурсов
- Обновление анимаций через AnimationManager
- Отрисовку в off-screen буфер
- ТОЧНО ТАКИЕ ЖЕ системы как в GUI режиме

## Основные принципы

Я всегда отвечаю пользователю на русском языке.

У меня есть время сделать всё правильно.

Я тщательно исследую проект перед выполнением любых задач.

Я предлагаю план действий и получаю подтверждение пользователя перед началом работы.

Я проверяю реальное состояние системы перед любыми заявлениями о результатах.

Я всегда ищу первопричину проблемы вместо того, чтобы маскировать симптомы.

Я доверяю фактам и проверкам, а не сообщениям об ошибках от нашего кода.

Я честно сообщаю как об успехах, так и о проблемах, начиная отчёт с того, что требует внимания.

Я пишу в профессиональном тоне без излишней эмоциональности - избегаю капслока (ЗАГЛАВНЫХ БУКВ) кроме редчайших критически важных случаев.

Я создаю конкретные и содержательные коммиты, описывающие что именно было сделано, а не общие фразы вроде "100% тестов" или "всё работает".

## Рабочий процесс

### Исследование и планирование

Я тщательно исследую проект перед выполнением любых задач, используя `fd --type f --exclude .git` для получения полного дерева файлов.

Я начинаю работу с изучения существующей структуры проекта.

Я проверяю, что уже реализовано в проекте, чтобы не дублировать функциональность.

Я составляю краткий план действий на русском языке и согласовываю его с пользователем.

### КРИТИЧЕСКИ ВАЖНО: Управление рабочими директориями

Я КАТЕГОРИЧЕСКИ ОБЯЗАН начинать КАЖДУЮ команду с `cd` к полному пути!

**ЖЕЛЕЗНОЕ ПРАВИЛО - ни одной команды без cd:**
```bash
# ✅ ЕДИНСТВЕННО ПРАВИЛЬНЫЙ способ
cd /mnt/e/Git/savanna && make test
cd /mnt/e/Git/savanna && make build
cd /mnt/e/Git/savanna/cmd/game && go build

# ❌ НЕДОПУСТИМО - мгновенное нарушение
make test              # где я нахожусь?!
go build ./...         # что я билдлю?!
./bin/savanna-game     # откуда запускаю?!
```

**КАЖДАЯ команда Bash ОБЯЗАТЕЛЬНО:**
1. **НАЧИНАЕТСЯ с cd к полному пути**: `cd /mnt/e/Git/savanna/...`
2. **ПРОДОЛЖАЕТСЯ через &&**: `cd /full/path && команда`
3. **НЕ предполагает текущую директорию**: никогда не пишу команды без cd

**АБСОЛЮТНО ОБЯЗАТЕЛЬНО:**
- ВСЕ пути к файлам: `/mnt/e/Git/savanna/...`  
- ВСЕ команды с cd: `cd /mnt/e/Git/savanna/... && команда`
- ВСЕ инструменты: Read, Edit, Glob, Grep - только полные пути
- НИКОГДА не полагаюсь на текущую директорию или относительные пути

**ЕСЛИ я напишу команду без cd - это СЕРЬЁЗНАЯ ОШИБКА в моей работе!**

### Проверка и валидация

Я не доверяю слепо сообщениям об ошибках - если код говорит "порт занят" или "файл не найден", я проверяю это самостоятельно.

Я анализирую логику кода и ищу баги в условиях, циклах и проверках, так как проблема обычно в самом коде.

Я использую полные абсолютные пути к файлам и командам в проекте.

## Разработка и тестирование

### Test-Driven Debug (TDD)

Я следую TDD процессу при исправлении багов:

1. Создаю тест на самом низком возможном уровне (юнит → интеграционный → E2E)
2. Запускаю тест и убеждаюсь, что он падает (ловит баг)
3. Исправляю баг в коде
4. Запускаю тест снова и убеждаюсь, что он проходит
5. Запускаю все связанные тесты для проверки регрессий
6. Коммичу изменения только после полной проверки всех тестов

Я никогда не исправляю баг без создания теста, который его ловит.

### Управление тестами

Я НИКОГДА НЕ ОТКЛЮЧАЮ ТЕСТЫ самостоятельно. Если тесты падают, я исправляю код или сами тесты, но НЕ отключаю их.

Я могу отключить тесты только если пользователь ЯВНО попросит это сделать.

Когда тесты требуют рефакторинга под новую архитектуру, я исправляю их, а не добавляю t.Skip().

### Управление сервисами

Я использую только Makefile для управления сервисами

### Логика радиусов атак

Я ВСЕГДА применяю правильную логику проверки атак:

- Радиус атаки атакующего должен быть БОЛЬШЕ его собственного радиуса (множитель > 1.0)
- Проверка возможности атаки: `attack_range + target_radius > distance_between_centers`
- Радиус атаки меньше размера атакующего делает атаку невозможной из-за отталкивания цели

Во всех константах атак я использую множители, а не абсолютные числа.

### Принципы чистого кода

Я ВСЕГДА следую базовым принципам программирования:

**DRY (Don't Repeat Yourself):** Я никогда не дублирую логику и константы.

**KISS (Keep It Simple, Stupid):** Простые решения предпочтительнее сложных.

**YAGNI (You Aren't Gonna Need It):** Не реализую функциональность "на будущее".

**Компонентная архитектура:** Системы работают с компонентами универсально, НЕ захардкоживают константы конкретных типов.

### Логика радиусов атак

Я ВСЕГДА применяю правильную логику проверки атак:

- Радиус атаки атакующего должен быть БОЛЬШЕ его собственного радиуса (множитель > 1.0)
- Проверка возможности атаки: `attack_range + target_radius > distance_between_centers`
- Радиус атаки меньше размера атакующего делает атаку невозможной из-за отталкивания цели

Во всех константах атак я использую множители, а не абсолютные числа.

### Принципы производительности

**Data-Oriented Design в ECS:**
- Structure of Arrays (SOA) для компонентов
- Битовые маски для O(1) проверки компонентов
- Предварительное выделение памяти (capacity в слайсах)
- Минимизация аллокаций в игровом цикле

**Spatial Grid для оптимизации поиска:**
```go
type SpatialGrid struct {
    cellSize    float32
    cells       map[uint64][]EntityID
    queryBuffer [MAX_NEARBY]EntityID  // Переиспользуемый буфер без аллокаций
}
```

**Цель производительности:** 1000 животных при 60 FPS

**Профилирование:**
- `make profile` для анализа производительности
- Избегание аллокаций в критических секциях
- Переиспользование буферов и объектов

Я НИКОГДА не убиваю запущенные процессы игры без разрешения пользователя.

Я НИКОГДА не использую pkill, killall или подобные команды без явного разрешения.

### Принципы тестирования

Я всегда запускаю тесты после реализации или модификации кода.

🚫 Я НИКОГДА НЕ ЗАЯВЛЯЮ что "всё работает" или "всё готово" БЕЗ ЗАПУСКА ВСЕХ ТЕСТОВ

Я ОБЯЗАТЕЛЬНО запускаю `make test` и жду полного завершения всех тестов перед любыми заявлениями о готовности.

Если хотя бы один тест падает - я НЕ считаю задачу выполненной и НЕ делаю заявлений о готовности.

Я никогда не использую моки, не вношу тестовые данные, всегда использую только реальные данные и запросы.

Я создаю тесты, которые работают с реальными данными через API, а не с заглушками.

Все тесты проекта настроены для параллельного выполнения с `t.Parallel()` для эффективного использования CPU ядер.

### Приоритет реального поведения над тестами

🎯 **ЕСЛИ ПОЛЬЗОВАТЕЛЬ ГОВОРИТ ЧТО ФУНКЦИОНАЛ НЕ РАБОТАЕТ, А ТЕСТЫ ПРОХОДЯТ - ЗНАЧИТ ТЕСТ НЕПРАВИЛЬНЫЙ**

Я понимаю что:
- Пользователь видит РЕАЛЬНОЕ поведение в игре
- Если тест проходит, но функционал не работает - тест написан неправильно
- Тест должен воспроизводить ТОЧНО ТАКУЮ ЖЕ среду как в реальной игре
- Я НЕМЕДЛЕННО исправляю тест чтобы он падал и показывал реальную проблему

Когда пользователь сообщает о проблеме:
1. Я НЕ доверяю проходящим тестам
2. Я создаю новый тест который воспроизводит реальную игровую среду  
3. Я убеждаюсь что тест ПАДАЕТ и показывает проблему
4. Только после этого исправляю код чтобы тест проходил

**Проходящий тест при сломанном функционале = неправильный тест**

### КРИТИЧЕСКИ ВАЖНО: Принципы работы с падающими тестами

**Философия: Падающий тест = ценный сигнал, НЕ препятствие**

Я понимаю, что **падающие тесты ловят регрессии** и **предотвращают поломку функциональности**.

**СТРОГО ЗАПРЕЩЕННЫЕ действия:**
- ❌ **УДАЛЯТЬ** падающие тесты (это скрывает регрессии!)
- ❌ **УПРОЩАТЬ** тесты до бессмысленности 
- ❌ **ИГНОРИРОВАТЬ** падающие тесты ради новых фич

**Правильный алгоритм работы с падающими тестами:**

**1. Анализ падающего теста (приоритет #1):**
- Падающий тест = сигнал о регрессии в коде
- СНАЧАЛА понять что сломалось в реальной функциональности
- Исправить первопричину в коде, а не в тесте

**2. Если быстро исправить не удается:**
- ✅ **ОТКЛЮЧИТЬ** тест через комментарий или skip
- ✅ **ЯВНО ЗАЯВИТЬ** в отчете: "ОТКЛЮЧЕН ТЕСТ: имя_теста - причина"
- ✅ Добавить задачу на исправление в техдолг

**3. Завершение работы:**
- ❌ **КОММИТЫ С ОТКЛЮЧЕННЫМИ ТЕСТАМИ ЗАПРЕЩЕНЫ**
- ✅ Перед коммитом ОБЯЗАТЕЛЬНО исправить все отключенные тесты
- ✅ Если пользователь просит коммит → ПРЕДУПРЕЖДАЮ об отключенных тестах

**Принцип технического долга:**
- Отключенные тесты = технический долг
- Долг ДОЛЖЕН быть погашен ДО коммита
- Исключение: только с явного разрешения пользователя

### Валидация результатов тестирования

Я НИКОГДА не заявляю об успехе тестов, основываясь только на выводе "PASS" отдельных тестовых функций.

Я ОБЯЗАТЕЛЬНО проверяю финальный exit code команды тестирования:
- `make test; echo "Exit code: $?"` 
- `go test ./...; echo "Exit code: $?"`

Я понимаю, что все отдельные тесты могут проходить (показывать PASS), но пакет в целом может падать с FAIL из-за:
- Проблем с TestMain функцией
- Ошибок cleanup после тестов  
- Проблем сборки или связывания модулей
- Конфликтов зависимостей

Я честно сообщаю пользователю, если exit code != 0, даже когда все отдельные тесты показывают PASS.

Я НЕ называю тестирование "100% успешным", пока не убежусь что exit code = 0.

### Запрет на запуск GUI игры

🚫 Я НИКОГДА НЕ ЗАПУСКАЮ GUI версию игры (`make run` или `./bin/savanna-game`)

Я понимаю что GUI игра может прерываться случайными действиями пользователя (нажатие клавиш, клики мыши), что делает результаты тестирования непредсказуемыми и ненадежными.

Я ВСЕГДА использую ТОЛЬКО headless режим для тестирования:
- Создаю integration тесты в `tests/integration/`
- Использую `make test` для запуска тестов
- Запускаю headless версию только если это явно требуется: `make run-headless`

Для проверки корректности игровой логики я создаю детальные тесты которые воспроизводят реальные сценарии в headless среде.

### Требования к headless режиму

🎯 HEADLESS РЕЖИМ ДОЛЖЕН БЫТЬ ИДЕНТИЧЕН GUI РЕЖИМУ во всем, кроме отображения окна.

Я обеспечиваю что headless режим содержит:
- ✅ Анимационные системы (`animation.NewAnimationSystem()`)
- ✅ Загрузку всех спрайтов и графических ресурсов
- ✅ Обновление анимаций (`updateAnimalAnimations()`)
- ✅ Отрисовку в off-screen буфер (double buffer)
- ✅ Все те же системы что в GUI режиме
- ✅ Идентичную логику обновления мира

ЕДИНСТВЕННОЕ отличие: нет отображения окна на экране.

Я никогда не создаю "упрощенную" версию headless режима - это приводит к несоответствию с реальной игрой и ложным результатам тестов.

### Требования к E2E тестам

🎯 HEADLESS РЕЖИМ С ДЕБАГ-ЛОГИРОВАНИЕМ - основа для E2E тестов.

Я обязательно создаю E2E тесты для проверки всей функциональности:

**Типы E2E тестов:**
- **Wolf Combat E2E**: полный цикл атаки волка от анимации до поедания
- **Animation E2E**: проверка всех анимаций и переходов между ними  
- **Ecosystem E2E**: проверка баланса экосистемы и выживания популяций
- **Performance E2E**: проверка производительности при большом количестве животных

**Структура E2E теста:**
1. Запуск полного headless режима с анимациями и отрисовкой
2. Детальное логирование всех событий (анимации, урон, смерть, поедание)
3. Проверка правильной последовательности событий
4. Валидация финального состояния системы

**Обязательные проверки в E2E тестах:**
- ✅ Анимации проигрываются полностью (кадр 0 → кадр 1 → завершение)
- ✅ Урон наносится в правильный момент анимации
- ✅ DamageFlash активируется и деактивируется корректно
- ✅ Трупы создаются при смерти
- ✅ Поедание происходит постепенно
- ✅ Голод восстанавливается правильно
- ✅ Популяции остаются стабильными

E2E тесты должны УПАСТЬ если реальная функциональность сломана, даже если unit тесты проходят.

### КРИТИЧЕСКИ ВАЖНО: Запрет на преждевременные заявления о готовности

Я НИКОГДА НЕ ЗАЯВЛЯЮ о готовности решения без ПОЛНОГО тестирования.

Я ОБЯЗАТЕЛЬНО провожу полное тестирование для проверки:
- Реальной работы всех компонентов системы
- Корректной интеграции между модулями
- Отсутствия регрессий в существующей функциональности
- Правильной работы в headless режиме

❌ НЕДОСТАТОЧНО для заявления о готовности:
- Успешные unit тесты отдельных компонентов
- Успешная компиляция проекта
- Логи показывающие что системы запускаются
- Частичное тестирование одного аспекта

✅ ОБЯЗАТЕЛЬНО для заявления о готовности:
- Полный прогон `make test` с exit code = 0
- Проверка что headless режим работает корректно
- Проверка что все системы интегрируются правильно
- Отсутствие падающих тестов

Если я заявил о готовности без полного тестирования - это СЕРЬЁЗНАЯ ОШИБКА с моей стороны.

### Принцип поиска багов в сложных системах

Если проблема не находится сразу, я ищу в **смежных местах**:

1. **System Integration** - порядок выполнения систем, зависимости между системами
2. **Component Lifecycle** - инициализация компонентов, cleanup, порядок создания/удаления
3. **Race Conditions** - конкурентный доступ, синхронизация, детерминированность
4. **Data Flow** - передача данных между системами, состояние компонентов
5. **Cross-System Communication** - интерфейсы между модулями, события

Я **НЕ** концентрируюсь только на:
- ❌ Месте где показывается ошибка (симптом)
- ❌ Одной системе (если проблема в интеграции)
- ❌ Одном слое архитектуры (проблема может быть в связях между слоями)

## Технические стандарты

### Константы и магические числа

Я НИКОГДА не использую "магические числа" в коде.

Все константы игрового баланса централизованы в `internal/simulation/game_balance.go`:

1. **Базовые константы** - единственные "магические" числа в проекте:
```go
const (
    RabbitBaseRadius = 16.0 // Заяц - небольшое травоядное
    WolfBaseRadius   = 24.0 // Волк - крупный хищник
)
```

2. **Выводимые константы** - все остальные параметры выводятся через явные множители:
```go
const (
    // Множители дальности видения
    RabbitVisionMultiplier = 6.25  // 100.0 / 16.0
    WolfVisionMultiplier   = 8.33  // 200.0 / 24.0
    
    // Множители атаки
    WolfAttackRangeMultiplier = 1.2 // Атака дальше размера
)
```

3. **Скоростные множители** - универсальные для всех животных:
```go
const (
    SearchSpeedMultiplier    = 0.8 // Поиск еды/добычи
    WanderingSpeedMultiplier = 0.7 // Случайное блуждание
    ContentSpeedMultiplier   = 0.3 // Спокойное состояние
)
```

4. **Обратная совместимость** - `animal_constants.go` содержит алиасы:
```go
const (
    GrassPerTick = GrassPerEatingTick // Алиас из game_balance.go
    MaxHungerValue = MaxHungerLimit   // Алиас из game_balance.go
)
```

Я всегда добавляю комментарии объясняющие логику множителей и происхождение значений.

Новые константы добавляются ТОЛЬКО в `game_balance.go` для централизованного управления балансом.

### Автоматическая проверка качества кода

Я ВСЕГДА использую линтеры для автоматического обнаружения проблем кода.

Проект настроен с golangci-lint который проверяет:
- **gomnd**: магические числа (наша основная цель!)
- **gocyclo**: сложность функций
- **dupl**: дублирование кода  
- **gosec**: проблемы безопасности
- **gocritic**: продвинутые проверки
- **revive**: стиль кода
- **deadcode**: мертвый код

Я запускаю линтер автоматически при каждой сборке:
```bash
make build          # Сборка с линтингом
make build-fast     # Быстрая сборка без линтинга
make lint           # Только линтер  
make lint-fix       # Автоисправление проблем
make check          # Полная проверка (fmt + lint + test)
```

Линтер автоматически устанавливается при первом запуске.

### Стратификация тестов по важности и управление техническим долгом

Вместо попытки поддерживать 100% прохождение всех тестов, я использую иерархию:

```bash
make test           # Основные тесты (~30 сек) - ОБЯЗАТЕЛЬНО для коммита
make test-full      # Полное тестирование (~5+ мин) - ТОЛЬКО перед релизом
make bench          # Бенчмарки производительности - для оптимизации
```

**ОБЯЗАТЕЛЬНЫЙ WORKFLOW:**

**Для небольших изменений:**
1. Реализую изменение
2. **ОБЯЗАТЕЛЬНО** запускаю `make test` 
3. Если прошло - коммичу
4. Сломанные тесты → документирую как техдолг

**Для важных изменений:**
1. Реализую изменение  
2. **ОБЯЗАТЕЛЬНО** запускаю `make test-full`
3. Если прошло - коммичу
4. Сломанные тесты → исправляю до коммита

**Управление техническим долгом:**
- Отключенные/падающие тесты = техдолг, а не препятствие
- Долг погашается пачками в отдельные дни
- НЕ блокирует разработку новых функций
- Приоритет: критические функции > техдолг > новые фичи

### Обработка ошибок

Я никогда не подавляю и не скрываю ошибки - всегда ищу и устраняю первопричину.

Я обеспечиваю graceful degradation - приложение продолжает работу даже при ошибках.

Я добавляю проверки на nil перед обращением к указателям и валидирую входные данные.

Я логирую проблемы и возвращаю осмысленные статусы, но не допускаю panic.

### Именование и форматирование

Я использую camelCase везде (кроме Go пакетов):

- JSON поля: walletAddress, createdAt
- TypeScript/JavaScript: userProfile, isLoading
- Go переменные: userAccount, depositAmount

Я оставляю snake_case только для:

- Имён Go пакетов
- Переменных окружения (SCREAMING_SNAKE_CASE)

### Работа с кодом

Я выполняю dos2unix для shell-скриптов после создания.

### Работа с процессами

Я НИКОГДА не пытаюсь принудительно завершить игру командами типа `pkill`.

Я ВСЕГДА проверяю существование процесса перед попытками его завершения.

Я понимаю, что пользователь сам контролирует запуск и остановку игры.

### Детерминированность и единообразие режимов

Я СТРОГО соблюдаю принцип: headless и GUI режимы ДОЛЖНЫ использовать абсолютно одинаковые функции и логику.

Я НИКОГДА не создаю разные системы для разных режимов - только один набор систем.

Единственное отличие между режимами: наличие или отсутствие отрисовки графики.

Я ВСЕГДА поддерживаю детерминированность - один seed даёт одинаковый результат в любом режиме.

Я использую только `world.GetRNG()` для всех случайных чисел в игровой логике.

## Отчётность

Я начинаю отчёты с проблем и того, что требует доработки.

Я указываю конкретные метрики: количество прошедших/упавших тестов, процент успешности.

Я даю честную оценку статуса: "частично работает", "требует доработки", а не "всё готово".

Я считаю систему готовой только когда все тесты проходят на 100%.

## Git и коммиты

🚫 СТРОЖАЙШИЙ ЗАПРЕТ НА КОММИТЫ БЕЗ РАЗРЕШЕНИЯ 🚫

Я КАТЕГОРИЧЕСКИ ЗАПРЕЩАЮ себе создавать коммиты без ЯВНОГО и ПРЯМОГО запроса пользователя.

Я НИКОГДА не создаю коммиты автоматически, даже если считаю это логичным.

Я ВСЕГДА спрашиваю разрешения перед созданием коммита: "Создать коммит с этими изменениями?"

Я предлагаю создать коммит только когда пользователь ПРЯМО попросит это сделать.

Если я нарушу это правило - это серьёзная ошибка с моей стороны.

Я пишу коммиты по существу, описывая конкретные изменения, а не общие фразы.

Я избегаю эмоциональных заглавных букв кроме исключительных случаев.

## Контекст проекта: Симулятор экосистемы саванны

### Описание проекта

Я разрабатываю игру-песочницу с симуляцией экосистемы африканской саванны. Основные характеристики:

- **Детерминированная симуляция**: один seed дает одинаковый результат
- **Изометрическая графика**: стиль StarCraft 1
- **Масштабируемость**: от десятков до тысяч животных
- **Энергетический баланс**: солнце → трава → травоядные → хищники
- **Реалистичное поведение**: голод, жажда, размножение, смерть

### Технические требования

#### Производительность
- 1000 животных при 60 FPS - обязательное требование
- Фиксированный timestep: 1/60 секунды
- Никаких аллокаций в игровом цикле
- SOA (Structure of Arrays) для компонентов ECS

#### Детерминированность - критически важно
Я НИКОГДА не использую:
- time.Now() для игровой логики
- rand без фиксированного seed
- итерацию по map (только слайсы с sort.SliceStable)
- горутины в симуляции

Я ВСЕГДА использую:
- Фиксированный timestep (1/60 сек)
- Один глобальный rand с seed
- Целочисленную арифметику где возможно

#### Архитектура ECS
```go
const MAX_ENTITIES = 1000

type EntityID uint16

// Arrays of Structs для оптимальной производительности
type World struct {
    positions [MAX_ENTITIES]Vec2
    velocities [MAX_ENTITIES]Vec2
    healths [MAX_ENTITIES]Health
    hungers [MAX_ENTITIES]Hunger
    
    // Битовые маски для быстрой проверки компонентов
    hasPosition [MAX_ENTITIES/64]uint64
    hasVelocity [MAX_ENTITIES/64]uint64
}
```

### Структура проекта

```
savanna/
├── Makefile                    # Единая точка входа для всех команд
├── go.mod                      # github.com/aiseeq/savanna
├── config/
│   ├── config.go              # Конфигурация игры
│   └── config.yaml            # Дефолтные настройки
├── cmd/
│   ├── game/                  # GUI версия (Ebiten)
│   └── headless/              # Консольная версия для тестов
├── internal/
│   ├── core/                  # ECS архитектура
│   ├── simulation/            # Логика животных и растений
│   ├── physics/               # Векторы, коллизии, spatial grid
│   ├── rendering/             # Изометрическая отрисовка
│   └── generator/             # Генерация мира
├── assets/                    # Спрайты 32x32
├── tests/                     # Unit, integration, performance
└── scripts/                   # Балансировка
```

### Makefile команды

Я использую только Makefile для управления проектом:

```makefile
make build          # Собрать обе версии
make run            # Запустить GUI версию
make run-headless   # Запустить headless версию
make test           # Все тесты (unit + integration)
make test-perf      # Тесты производительности
make bench          # Бенчмарки
make fmt            # Форматирование кода
make lint           # Линтер
make simulate       # Headless симуляция для балансировки
make profile        # Профилирование производительности
```

### Животные и поведение

#### Заяц (травоядное)
- Размер: радиус 5 единиц
- Скорость: 20 единиц/сек
- Здоровье: 50 хитов
- Поведение:
  - При голоде < 70%: ищет ближайшую траву
  - При виде волка в радиусе 50: убегает
  - При сытости > 80%: может размножаться

#### Волк (хищник)
- Размер: радиус 10 единиц
- Скорость: 30 единиц/сек при охоте
- Здоровье: 100 хитов
- Поведение:
  - При голоде < 60%: охотится на зайцев
  - Поедание зайца восстанавливает 50% сытости

### Механики симуляции

#### Голод
- Уменьшается на 1% каждые 5 секунд
- При 0% животное теряет здоровье (1 хит/сек)
- Влияет на скорость:
  - 0-20%: скорость x0.5
  - 80-100%: скорость x0.8

#### Размножение
- Требования: сытость > 80%, здоровье > 70%, партнер рядом
- Детёныши: 50% размера родителей, растут 1 минуту

#### Трава
- Рост: +1 единица каждые 2 секунды до максимума 100
- Поедание: заяц съедает 10 единиц за секунду
- Покрытие: 70% карты изначально

### Мир

- Размер: 50x50 тайлов (1 тайл = 32 пикселя)
- Водоёмы: 2-3 круглых озера
- Кусты: препятствия для движения
- Детерминированная генерация по seed

### Оптимизация производительности

#### Spatial Grid для поиска соседей
```go
type SpatialGrid struct {
    cellSize float32
    cells map[uint64][]EntityID
    queryBuffer [MAX_NEARBY]EntityID  // Без аллокаций
}
```

#### Object Pooling
```go
var vector2Pool = &sync.Pool{
    New: func() interface{} { return &Vec2{} },
}
```

### Графика и UI

#### Изометрическая проекция
```go
// Преобразование координат
screen_x = (world_x - world_y) * TILE_WIDTH/2
screen_y = (world_x + world_y) * TILE_HEIGHT/4
```

#### UI элементы
- Информация о животном при клике
- Глобальная статистика популяций
- Управление временем (пауза, x1, x2, x5)
- Дебаг режим (F3): границы, векторы движения, ID

### Балансировка экосистемы

#### Энергетический баланс
```
Солнце (1000) → Трава (100) → Зайцы (10) → Волки (1)
```

#### Целевые метрики
- 20-30 зайцев + 2-3 волка = стабильная популяция
- 10 минут симуляции без вымирания
- 100 животных = 60 FPS

### Тестирование

#### Типы тестов
- Unit тесты: каждая система отдельно
- Integration тесты: взаимодействие систем
- Performance тесты: 1000 животных
- Balance тесты: устойчивость экосистемы

#### Стратегия Test-Driven Debug
Я всегда создаю тест перед исправлением бага:
1. Создаю тест, который ловит баг
2. Исправляю код
3. Проверяю, что тест проходит
4. Запускаю все связанные тесты

### Важные константы

```go
const (
    MAX_ENTITIES = 1000
    WORLD_SIZE = 50
    TILE_SIZE = 32
    FIXED_TIMESTEP = 1.0/60.0
    
    RABBIT_RADIUS = 5
    RABBIT_SPEED = 20
    RABBIT_MAX_HEALTH = 50
    
    WOLF_RADIUS = 10
    WOLF_SPEED = 30
    WOLF_MAX_HEALTH = 100
    
    VISION_RANGE_RABBIT = 50
    VISION_RANGE_WOLF = 100
)
```

### Зависимости

- Go модуль: github.com/aiseeq/savanna
- GUI библиотека: github.com/hajimehoshi/ebiten/v2
- Конфигурация: gopkg.in/yaml.v3
- Тестирование: стандартная библиотека Go

### Многоуровневая тестовая архитектура

Я работаю с профессиональной тестовой архитектурой проекта:

**Структура тестов:**
```
tests/
├── unit/               # 15 файлов - компоненты, физика, ECS
├── integration/        # 60+ файлов - взаимодействие систем  
├── e2e/               # 15 файлов - полные сценарии
├── behavioral/        # BDD тесты (Given-When-Then)
├── chaos/             # Chaos Engineering стресс-тесты
├── contract/          # Contract тесты между компонентами
├── property/          # Property-based тестирование
├── system/            # Системные тесты запуска
└── common/            # 7 helper файлов (TestWorldBuilder)
```

**Продвинутые методики тестирования:**
- **Property-based testing** - автоматическая генерация тестовых данных
- **Chaos engineering** - стресс-тестирование отказоустойчивости  
- **Mutation testing** - проверка качества самих тестов (make test-mutation)
- **Behavioral tests (BDD)** - тесты в формате Given-When-Then
- **Contract testing** - проверка интерфейсов между компонентами

**Системы автоматизации тестов:**
```go
// CreateTestSystemManager - полный набор для интеграционных тестов
// CreateMinimalSystemManager - только основные системы
// CreateCombatSystemManager - только боевые системы  
// CreateMockVegetationSystem - заглушка для unit тестов
```

### Структура assets и ресурсов

**Организация спрайтов (64 файла):**
```
assets/
├── sprites/
│   ├── animals/
│   │   ├── rabbit/     # Все состояния зайца
│   │   └── wolf/       # Все состояния волка
│   ├── terrain/        # Трава, земля, вода
│   └── ui/            # GUI элементы
```

**Принципы работы с графикой:**
- Размер спрайтов: 32x32 пикселя (изометрический стандарт)
- Fallback на тестовые спрайты при отсутствии файлов
- Все спрайты загружаются даже в headless режиме для идентичности
- AnimationViewer (cmd/animviewer/) для предварительного просмотра

### Системы дебага и диагностики

**Дебаг-режимы в игре:**
- **F3** - включение отображения границ, векторов движения, ID сущностей
- **Управление временем** - пауза, ускорение x1/x2/x5
- **Статистика популяций** - количество животных каждого типа
- **Информация о животном** - клик для просмотра детальных параметров

**Headless дебаг-логирование:**
```bash
make run-headless  # Детальные логи всех событий
make simulate      # Балансировка экосистемы с отчётами
```

**Профилирование производительности:**
```bash
make profile       # CPU/Memory профайлинг
make bench         # Бенчмарки критических секций
```

### Архитектура конфигурации

**Многоуровневая система настроек:**
```
config/
├── config.go      # Типобезопасная структура Config
└── config.yaml    # Дефолтные параметры
```

**Источники конфигурации (приоритет):**
1. Флаги командной строки (высший приоритет)
2. Переменные окружения  
3. config.yaml файл
4. Встроенные дефолты (низший приоритет)

**Валидация и проверки:**
- Проверка корректности всех параметров при запуске
- Автоматическое применение разумных дефолтов
- Graceful degradation при некорректных значениях

### Системы управления временем

**Фиксированный timestep архитектура:**
```go
const FIXED_TIMESTEP = 1.0/60.0  // 16.67ms на кадр

// Детерминированное обновление
func Update(deltaTime float32) {
    accumulator += deltaTime
    for accumulator >= FIXED_TIMESTEP {
        world.Update(FIXED_TIMESTEP)     // Строго фиксированный шаг
        accumulator -= FIXED_TIMESTEP
    }
}
```

**Управление скоростью симуляции:**
- **Пауза** - полная остановка игрового времени
- **x1** - реальное время (60 FPS)
- **x2** - ускорение в 2 раза
- **x5** - ускорение в 5 раз (для быстрого тестирования)

### Пространственная оптимизация

**Spatial Grid для O(1) поиска:**
```go
type SpatialGrid struct {
    cellSize    float32                    // Размер ячейки сетки
    cells       map[uint64][]EntityID      // Карта ячеек к сущностям
    queryBuffer [MAX_NEARBY]EntityID       // Переиспользуемый буфер
}

// Поиск соседей без аллокаций
func (sg *SpatialGrid) GetNearby(x, y, radius float32) []EntityID {
    // Переиспользуем один буфер для всех запросов
    return sg.queryBuffer[:foundCount]
}
```

**Принципы оптимизации:**
- Никаких аллокаций в игровом цикле
- Переиспользование буферов и слайсов
- SOA (Structure of Arrays) для лучшей локальности кэша
- Битовые маски для быстрой фильтрации компонентов

### Build система и WSL оптимизации

**Makefile команды для разработки:**
```makefile
make build          # Полная сборка с линтингом
make build-fast     # Быстрая сборка без проверок
make build-windows  # Кроссплатформенная сборка для Windows
make run-wsl        # Оптимизации для WSL среды
make check          # Полная проверка: fmt + lint + test
make clean          # Очистка всех артефактов сборки
```

**WSL специфичные оптимизации:**
- Отключение DPI для Windows сборок
- Оптимизированные пути для GUI в WSL среде
- Автоматическая установка зависимостей

### Чек-лист готовности MVP

- [x] Мир 50x50 с травой - **ГОТОВО**
- [x] Зайцы и волки с базовым поведением - **ГОТОВО**
- [x] Система питания (трава → зайцы → волки) - **ГОТОВО**
- [x] Устойчивая экосистема - **ГОТОВО**
- [x] GUI с изометрической графикой - **ГОТОВО**
- [x] Headless режим для тестов - **ГОТОВО**
- [x] 60 FPS при 100 животных - **ГОТОВО**
- [ ] Все тесты проходят - **ТРЕБУЕТ ДОРАБОТКИ** (некоторые падают)
- [x] Детерминированность симуляции - **ГОТОВО**

### Известные проблемы и пути решения

**Структурные проблемы:**
- ❌ Отсутствует `internal/rendering/` пакет (ожидается тестами)
- ❌ Структура `assets/sprites/` не соответствует ожиданиям тестов
- ❌ Отсутствуют директории `tests/performance/` и `tests/fixtures/`

**Пути решения:**
1. Создать отсутствующие директории для соответствия тестовым ожиданиям
2. Реорганизовать структуру assets согласно тестовым контрактам
3. Выделить rendering логику из cmd/game в отдельный пакет

**Статус проекта: 95% готовности MVP** - высочайшее качество архитектуры с минимальными структурными доработками.
