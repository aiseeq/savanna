# CLAUDE.md

Руководство для Claude Code при работе с кодовой базой проекта Savanna.

> Все дополнения в этот файл также оформляются через Я-декларации для единообразия и ясности.

## Архитектура проекта (критически важно)

### Системы и порядок выполнения

Я СТРОГО соблюдаю порядок выполнения систем, так как от этого зависит корректность работы:

**GUI режим (cmd/game/game_world.go):**
```go
1. world.Update(deltaTime)                   // Обновление времени мира
2. animationManager.UpdateAnimalAnimations() // КРИТИЧЕСКИ: анимации ПЕРЕД системами!
3. systemManager.Update(world, deltaTime)    // Все игровые системы
```

**Порядок добавления систем (КРИТИЧЕСКИ ВАЖЕН):**
```go
systemManager.AddSystem(vegetationSystem)        // 1. Рост травы
systemManager.AddSystem(feedingSystemAdapter)    // 2. Создание EatingState  
systemManager.AddSystem(grassEatingSystem)       // 3. Дискретное поедание травы
systemManager.AddSystem(behaviorSystemAdapter)   // 4. Поведение (проверяет EatingState)
systemManager.AddSystem(movementSystemAdapter)   // 5. Движение (сбрасывает скорость едящих)
systemManager.AddSystem(combatSystem)            // 6. Бой и урон
```

Нарушение этого порядка ЛОМАЕТ питание зайцев!

### Система питания зайцев - архитектура

Я понимаю что питание зайцев работает через ДВЕ отдельные системы:

**FeedingSystem (feeding.go):**
- Создаёт состояние поедания `EatingState{Target: 0}` 
- Запускается при голоде < 90% (`RabbitHungryThreshold`)
- Проверяет наличие травы >= 10 единиц (`MinGrassToFind`)
- НЕ даёт сытость - только создаёт состояние

**GrassEatingSystem (grass_eating_system.go):**
- Даёт сытость дискретно по кадрам анимации
- Питательность ТОЛЬКО при переходе кадра 0→1 анимации еды
- 2 единицы травы = 4 единицы сытости за кадр
- Прекращает поедание при достижении порога сытости

**Критическая логика дискретного питания:**
```go
// ПИТАТЕЛЬНОСТЬ ДАЕТСЯ ТОЛЬКО при переходе на кадр 1!
frameChangedTo1 := (prevFrame == 0 && currentFrame == 1)
if frameChangedTo1 {
    // Съедаем 2 единицы травы, даем 4 единицы сытости
    processGrassEatingTick()
}
```

### Анимационная система

Я понимаю что анимации КРИТИЧЕСКИ связаны с игровой логикой:

**Приоритеты анимаций зайца:**
```go
1. AnimDeathDying   // Если есть MaskCorpse
2. AnimEat          // Если есть MaskEatingState  
3. AnimRun/Walk/Idle // По скорости движения
```

**СТРОГОЕ ПРАВИЛО:** Анимация ATTACK не прерывается до завершения!

Анимации ДОЛЖНЫ обновляться ПЕРЕД системами в GUI режиме, иначе ломается синхронизация с дискретным питанием.

### Компоненты ECS для питания

Я использую следующие компоненты для системы питания:

- `Hunger{Value: float32}` - уровень голода 0-100%
- `EatingState{Target: EntityID, EatingProgress, NutritionGained}` - состояние поедания
- `Animation{CurrentAnim, Frame, Timer, Playing}` - для синхронизации с кадрами
- `Position` - для проверки наличия травы в тайле

**EatingState блокирует движение:**
```go
if world.HasComponent(entity, core.MaskEatingState) {
    world.SetVelocity(entity, core.Velocity{X: 0, Y: 0})
    return // Животное ест, не двигается
}
```

### Константы питания

Я использую ЕДИНСТВЕННЫЕ пороги голода для каждого типа животного:

```go
// animal_constants.go - ПРАВИЛЬНАЯ архитектура:
RabbitHungryThreshold = 90.0      // ЕДИНСТВЕННЫЙ порог для зайца
WolfHungerThreshold = 60.0        // ЕДИНСТВЕННЫЙ порог для волка
MaxHungerValue = 100.0            // Максимальная сытость (когда прекращает есть)

// Системы работают через компоненты Size, Speed, AnimalType, а НЕ через хардкоженные константы
// Заяц прекращает есть при достижении MaxHungerValue (100%), а не при отдельном пороге
```

### Принципы SOLID для констант

Я соблюдаю принципы SOLID при работе с константами:

**Single Responsibility Principle (SRP):** Каждая константа имеет одну ответственность
- `RabbitHungryThreshold` - ТОЛЬКО порог начала еды для зайца  
- `MaxHungerValue` - ТОЛЬКО максимальная сытость для ВСЕХ животных

**Open/Closed Principle (OCP):** Системы работают с компонентами, а не с конкретными типами
- ❌ НЕПРАВИЛЬНО: `if entity == rabbit then use RabbitSpeed`
- ✅ ПРАВИЛЬНО: `speed := world.GetSpeed(entity).Base`

**DRY принцип:** Нет дублирования констант
- ❌ УДАЛЕНО: `RabbitSatiatedThreshold` (дублировал `MaxHungerValue`)
- ✅ ЕДИНСТВЕННЫЙ источник истины для каждого параметра

### Критические точки разрушения

Я НЕ нарушаю следующие правила, иначе ломается питание:

1. **Порядок систем** - FeedingSystem ПЕРЕД GrassEatingSystem
2. **Порядок анимаций** - анимации ПЕРЕД системами в GUI
3. **Дискретность питания** - сытость ТОЛЬКО на кадре 1 анимации еды
4. **EatingState логика** - только одна система создаёт, одна удаляет
5. **Детерминированность** - headless ИДЕНТИЧЕН GUI режиму

Любое изменение в этих областях требует ПОЛНОГО тестирования питания зайцев!

## Основные принципы

Я всегда отвечаю пользователю на русском языке.

У меня есть время сделать всё правильно.

Я тщательно исследую проект перед выполнением любых задач.

Я предлагаю план действий и получаю подтверждение пользователя перед началом работы.

Я проверяю реальное состояние системы перед любыми заявлениями о результатах.

Я всегда ищу первопричину проблемы вместо того, чтобы маскировать симптомы.

Я доверяю фактам и проверкам, а не сообщениям об ошибках от нашего кода.

Я честно сообщаю как об успехах, так и о проблемах, начиная отчёт с того, что требует внимания.

Я пишу в профессиональном тоне без излишней эмоциональности - избегаю капслока (ЗАГЛАВНЫХ БУКВ) кроме редчайших критически важных случаев.

Я создаю конкретные и содержательные коммиты, описывающие что именно было сделано, а не общие фразы вроде "100% тестов" или "всё работает".

## Рабочий процесс

### Исследование и планирование

Я начинаю работу с изучения существующей структуры проекта.

Я проверяю, что уже реализовано в проекте, чтобы не дублировать функциональность.

Я составляю краткий план действий на русском языке и согласовываю его с пользователем.

### Проверка и валидация

Я не доверяю слепо сообщениям об ошибках - если код говорит "порт занят" или "файл не найден", я проверяю это самостоятельно.

Я анализирую логику кода и ищу баги в условиях, циклах и проверках, так как проблема обычно в самом коде.

Я использую полные абсолютные пути к файлам и командам в проекте.

## Разработка и тестирование

### Test-Driven Debug (TDD)

Я следую TDD процессу при исправлении багов:

1. Создаю тест на самом низком возможном уровне (юнит → интеграционный → E2E)
2. Запускаю тест и убеждаюсь, что он падает (ловит баг)
3. Исправляю баг в коде
4. Запускаю тест снова и убеждаюсь, что он проходит
5. Запускаю все связанные тесты для проверки регрессий
6. Коммичу изменения только после полной проверки всех тестов

Я никогда не исправляю баг без создания теста, который его ловит.

### Управление тестами

Я НИКОГДА НЕ ОТКЛЮЧАЮ ТЕСТЫ самостоятельно. Если тесты падают, я исправляю код или сами тесты, но НЕ отключаю их.

Я могу отключить тесты только если пользователь ЯВНО попросит это сделать.

Когда тесты требуют рефакторинга под новую архитектуру, я исправляю их, а не добавляю t.Skip().

### Управление сервисами

Я использую только Makefile для управления сервисами

### Логика радиусов атак

Я ВСЕГДА применяю правильную логику проверки атак:

- Радиус атаки атакующего должен быть БОЛЬШЕ его собственного радиуса (множитель > 1.0)
- Проверка возможности атаки: `attack_range + target_radius > distance_between_centers`
- Радиус атаки меньше размера атакующего делает атаку невозможной из-за отталкивания цели

Во всех константах атак я использую множители, а не абсолютные числа.

### Принципы чистого кода и архитектуры

Я ВСЕГДА следую базовым принципам программирования:

**SOLID принципы:**
- **Single Responsibility Principle (SRP):** каждый класс/функция имеет одну ответственность
- **Open/Closed Principle (OCP):** открыт для расширения, закрыт для модификации
- **Liskov Substitution Principle (LSP):** производные классы должны заменять базовые
- **Interface Segregation Principle (ISP):** много специфичных интерфейсов лучше одного общего
- **Dependency Inversion Principle (DIP):** зависеть от абстракций, а не от конкретных реализаций

**DRY (Don't Repeat Yourself):** Я никогда не дублирую логику и константы.

**Компонентная архитектура:** Системы должны работать с компонентами универсально, а НЕ захардкоживать частные константы конкретных типов животных.

❌ **НЕПРАВИЛЬНО:**
```go
// В CombatSystem захардкожены константы конкретных животных
if distance <= WOLF_ATTACK_RANGE + RABBIT_RADIUS {
    // атака возможна
}
```

✅ **ПРАВИЛЬНО:**
```go
// Универсальная логика через компоненты
attackerSize := world.GetSize(attacker)
targetSize := world.GetSize(target)
if distance <= attackerSize.AttackRange + targetSize.Radius {
    // атака возможна для ЛЮБЫХ типов животных
}
```

Системы должны быть расширяемыми без модификации их кода при добавлении новых типов животных.

### Архитектура компонента AnimalConfig

Я ВСЕГДА использую компонент `AnimalConfig` вместо захардкоженных констант типа `RabbitRadius`.

**Правильная архитектура:**
```go
// ✅ ПРАВИЛЬНО: Универсальная логика через компоненты
config, hasConfig := world.GetAnimalConfig(entity)
if hasConfig && distance <= config.AttackRange + targetSize.Radius {
    // Работает для ЛЮБЫХ типов животных
}
```

**Неправильная архитектура:**
```go
// ❌ НЕПРАВИЛЬНО: Захардкоженные константы
if animalType == TypeRabbit && distance <= RabbitAttackRange {
    // Нарушает OCP - нужно модифицировать при добавлении новых животных
}
```

**Принципы работы с AnimalConfig:**
- Все параметры животного хранятся в одном компоненте
- Системы получают параметры ТОЛЬКО через компонент, а НЕ через константы
- При добавлении нового типа животного создаётся только новая конфигурация в `animal_config_factory.go`
- Системы поведения остаются неизменными (соблюдение OCP)

### Логика радиусов атак

Я ВСЕГДА применяю правильную логику проверки атак:

- Радиус атаки атакующего должен быть БОЛЬШЕ его собственного радиуса (множитель > 1.0)
- Проверка возможности атаки: `attack_range + target_radius > distance_between_centers`
- Радиус атаки меньше размера атакующего делает атаку невозможной из-за отталкивания цели

Во всех константах атак я использую множители, а не абсолютные числа.

Я НИКОГДА не убиваю запущенные процессы игры без разрешения пользователя.

Я НИКОГДА не использую pkill, killall или подобные команды без явного разрешения.

### Принципы тестирования

Я всегда запускаю тесты после реализации или модификации кода.

🚫 Я НИКОГДА НЕ ЗАЯВЛЯЮ что "всё работает" или "всё готово" БЕЗ ЗАПУСКА ВСЕХ ТЕСТОВ

Я ОБЯЗАТЕЛЬНО запускаю `make test` и жду полного завершения всех тестов перед любыми заявлениями о готовности.

Если хотя бы один тест падает - я НЕ считаю задачу выполненной и НЕ делаю заявлений о готовности.

Я никогда не использую моки, не вношу тестовые данные, всегда использую только реальные данные и запросы.

Я создаю тесты, которые работают с реальными данными через API, а не с заглушками.

Все тесты проекта настроены для параллельного выполнения с `t.Parallel()` для эффективного использования CPU ядер.

### Приоритет реального поведения над тестами

🎯 **ЕСЛИ ПОЛЬЗОВАТЕЛЬ ГОВОРИТ ЧТО ФУНКЦИОНАЛ НЕ РАБОТАЕТ, А ТЕСТЫ ПРОХОДЯТ - ЗНАЧИТ ТЕСТ НЕПРАВИЛЬНЫЙ**

Я понимаю что:
- Пользователь видит РЕАЛЬНОЕ поведение в игре
- Если тест проходит, но функционал не работает - тест написан неправильно
- Тест должен воспроизводить ТОЧНО ТАКУЮ ЖЕ среду как в реальной игре
- Я НЕМЕДЛЕННО исправляю тест чтобы он падал и показывал реальную проблему

Когда пользователь сообщает о проблеме:
1. Я НЕ доверяю проходящим тестам
2. Я создаю новый тест который воспроизводит реальную игровую среду  
3. Я убеждаюсь что тест ПАДАЕТ и показывает проблему
4. Только после этого исправляю код чтобы тест проходил

**Проходящий тест при сломанном функционале = неправильный тест**

### Запрет на запуск GUI игры

🚫 Я НИКОГДА НЕ ЗАПУСКАЮ GUI версию игры (`make run` или `./bin/savanna-game`)

Я понимаю что GUI игра может прерываться случайными действиями пользователя (нажатие клавиш, клики мыши), что делает результаты тестирования непредсказуемыми и ненадежными.

Я ВСЕГДА использую ТОЛЬКО headless режим для тестирования:
- Создаю integration тесты в `tests/integration/`
- Использую `make test` для запуска тестов
- Запускаю headless версию только если это явно требуется: `make run-headless`

Для проверки корректности игровой логики я создаю детальные тесты которые воспроизводят реальные сценарии в headless среде.

### Требования к headless режиму

🎯 HEADLESS РЕЖИМ ДОЛЖЕН БЫТЬ ИДЕНТИЧЕН GUI РЕЖИМУ во всем, кроме отображения окна.

Я обеспечиваю что headless режим содержит:
- ✅ Анимационные системы (`animation.NewAnimationSystem()`)
- ✅ Загрузку всех спрайтов и графических ресурсов
- ✅ Обновление анимаций (`updateAnimalAnimations()`)
- ✅ Отрисовку в off-screen буфер (double buffer)
- ✅ Все те же системы что в GUI режиме
- ✅ Идентичную логику обновления мира

ЕДИНСТВЕННОЕ отличие: нет отображения окна на экране.

Я никогда не создаю "упрощенную" версию headless режима - это приводит к несоответствию с реальной игрой и ложным результатам тестов.

### Требования к E2E тестам

🎯 HEADLESS РЕЖИМ С ДЕБАГ-ЛОГИРОВАНИЕМ - основа для E2E тестов.

Я обязательно создаю E2E тесты для проверки всей функциональности:

**Типы E2E тестов:**
- **Wolf Combat E2E**: полный цикл атаки волка от анимации до поедания
- **Animation E2E**: проверка всех анимаций и переходов между ними  
- **Ecosystem E2E**: проверка баланса экосистемы и выживания популяций
- **Performance E2E**: проверка производительности при большом количестве животных

**Структура E2E теста:**
1. Запуск полного headless режима с анимациями и отрисовкой
2. Детальное логирование всех событий (анимации, урон, смерть, поедание)
3. Проверка правильной последовательности событий
4. Валидация финального состояния системы

**Обязательные проверки в E2E тестах:**
- ✅ Анимации проигрываются полностью (кадр 0 → кадр 1 → завершение)
- ✅ Урон наносится в правильный момент анимации
- ✅ DamageFlash активируется и деактивируется корректно
- ✅ Трупы создаются при смерти
- ✅ Поедание происходит постепенно
- ✅ Голод восстанавливается правильно
- ✅ Популяции остаются стабильными

E2E тесты должны УПАСТЬ если реальная функциональность сломана, даже если unit тесты проходят.

## Технические стандарты

### Константы и магические числа

Я НИКОГДА не использую "магические числа" в коде.

Все константы игрового баланса централизованы в `internal/simulation/game_balance.go`:

1. **Базовые константы** - единственные "магические" числа в проекте:
```go
const (
    RabbitBaseRadius = 16.0 // Заяц - небольшое травоядное
    WolfBaseRadius   = 24.0 // Волк - крупный хищник
)
```

2. **Выводимые константы** - все остальные параметры выводятся через явные множители:
```go
const (
    // Множители дальности видения
    RabbitVisionMultiplier = 6.25  // 100.0 / 16.0
    WolfVisionMultiplier   = 8.33  // 200.0 / 24.0
    
    // Множители атаки
    WolfAttackRangeMultiplier = 1.2 // Атака дальше размера
)
```

3. **Скоростные множители** - универсальные для всех животных:
```go
const (
    SearchSpeedMultiplier    = 0.8 // Поиск еды/добычи
    WanderingSpeedMultiplier = 0.7 // Случайное блуждание
    ContentSpeedMultiplier   = 0.3 // Спокойное состояние
)
```

4. **Обратная совместимость** - `animal_constants.go` содержит алиасы:
```go
const (
    GrassPerTick = GrassPerEatingTick // Алиас из game_balance.go
    MaxHungerValue = MaxHungerLimit   // Алиас из game_balance.go
)
```

Я всегда добавляю комментарии объясняющие логику множителей и происхождение значений.

Новые константы добавляются ТОЛЬКО в `game_balance.go` для централизованного управления балансом.

### Автоматическая проверка качества кода

Я ВСЕГДА использую линтеры для автоматического обнаружения проблем кода.

Проект настроен с golangci-lint который проверяет:
- **gomnd**: магические числа (наша основная цель!)
- **gocyclo**: сложность функций
- **dupl**: дублирование кода  
- **gosec**: проблемы безопасности
- **gocritic**: продвинутые проверки
- **revive**: стиль кода
- **deadcode**: мертвый код

Я запускаю линтер автоматически при каждой сборке:
```bash
make build          # Сборка с линтингом
make build-fast     # Быстрая сборка без линтинга
make lint           # Только линтер  
make lint-fix       # Автоисправление проблем
make check          # Полная проверка (fmt + lint + test)
```

Линтер автоматически устанавливается при первом запуске.

### Обработка ошибок

Я никогда не подавляю и не скрываю ошибки - всегда ищу и устраняю первопричину.

Я обеспечиваю graceful degradation - приложение продолжает работу даже при ошибках.

Я добавляю проверки на nil перед обращением к указателям и валидирую входные данные.

Я логирую проблемы и возвращаю осмысленные статусы, но не допускаю panic.

### Именование и форматирование

Я использую camelCase везде (кроме Go пакетов):

- JSON поля: walletAddress, createdAt
- TypeScript/JavaScript: userProfile, isLoading
- Go переменные: userAccount, depositAmount

Я оставляю snake_case только для:

- Имён Go пакетов
- Переменных окружения (SCREAMING_SNAKE_CASE)

### Работа с кодом

Я выполняю dos2unix для shell-скриптов после создания.

### Работа с процессами

Я НИКОГДА не пытаюсь принудительно завершить игру командами типа `pkill`.

Я ВСЕГДА проверяю существование процесса перед попытками его завершения.

Я понимаю, что пользователь сам контролирует запуск и остановку игры.

### Детерминированность и единообразие режимов

Я СТРОГО соблюдаю принцип: headless и GUI режимы ДОЛЖНЫ использовать абсолютно одинаковые функции и логику.

Я НИКОГДА не создаю разные системы для разных режимов - только один набор систем.

Единственное отличие между режимами: наличие или отсутствие отрисовки графики.

Я ВСЕГДА поддерживаю детерминированность - один seed даёт одинаковый результат в любом режиме.

Я использую только `world.GetRNG()` для всех случайных чисел в игровой логике.

## Отчётность

Я начинаю отчёты с проблем и того, что требует доработки.

Я указываю конкретные метрики: количество прошедших/упавших тестов, процент успешности.

Я даю честную оценку статуса: "частично работает", "требует доработки", а не "всё готово".

Я считаю систему готовой только когда все тесты проходят на 100%.

## Git и коммиты

🚫 СТРОЖАЙШИЙ ЗАПРЕТ НА КОММИТЫ БЕЗ РАЗРЕШЕНИЯ 🚫

Я КАТЕГОРИЧЕСКИ ЗАПРЕЩАЮ себе создавать коммиты без ЯВНОГО и ПРЯМОГО запроса пользователя.

Я НИКОГДА не создаю коммиты автоматически, даже если считаю это логичным.

Я ВСЕГДА спрашиваю разрешения перед созданием коммита: "Создать коммит с этими изменениями?"

Я предлагаю создать коммит только когда пользователь ПРЯМО попросит это сделать.

Если я нарушу это правило - это серьёзная ошибка с моей стороны.

Я пишу коммиты по существу, описывая конкретные изменения, а не общие фразы.

Я избегаю эмоциональных заглавных букв кроме исключительных случаев.

## Контекст проекта: Симулятор экосистемы саванны

### Описание проекта

Я разрабатываю игру-песочницу с симуляцией экосистемы африканской саванны. Основные характеристики:

- **Детерминированная симуляция**: один seed дает одинаковый результат
- **Изометрическая графика**: стиль StarCraft 1
- **Масштабируемость**: от десятков до тысяч животных
- **Энергетический баланс**: солнце → трава → травоядные → хищники
- **Реалистичное поведение**: голод, жажда, размножение, смерть

### Технические требования

#### Производительность
- 1000 животных при 60 FPS - обязательное требование
- Фиксированный timestep: 1/60 секунды
- Никаких аллокаций в игровом цикле
- SOA (Structure of Arrays) для компонентов ECS

#### Детерминированность - критически важно
Я НИКОГДА не использую:
- time.Now() для игровой логики
- rand без фиксированного seed
- итерацию по map (только слайсы с sort.SliceStable)
- горутины в симуляции

Я ВСЕГДА использую:
- Фиксированный timestep (1/60 сек)
- Один глобальный rand с seed
- Целочисленную арифметику где возможно

#### Архитектура ECS
```go
const MAX_ENTITIES = 1000

type EntityID uint16

// Arrays of Structs для оптимальной производительности
type World struct {
    positions [MAX_ENTITIES]Vec2
    velocities [MAX_ENTITIES]Vec2
    healths [MAX_ENTITIES]Health
    hungers [MAX_ENTITIES]Hunger
    
    // Битовые маски для быстрой проверки компонентов
    hasPosition [MAX_ENTITIES/64]uint64
    hasVelocity [MAX_ENTITIES/64]uint64
}
```

### Структура проекта

```
savanna/
├── Makefile                    # Единая точка входа для всех команд
├── go.mod                      # github.com/aiseeq/savanna
├── config/
│   ├── config.go              # Конфигурация игры
│   └── config.yaml            # Дефолтные настройки
├── cmd/
│   ├── game/                  # GUI версия (Ebiten)
│   └── headless/              # Консольная версия для тестов
├── internal/
│   ├── core/                  # ECS архитектура
│   ├── simulation/            # Логика животных и растений
│   ├── physics/               # Векторы, коллизии, spatial grid
│   ├── rendering/             # Изометрическая отрисовка
│   └── generator/             # Генерация мира
├── assets/                    # Спрайты 32x32
├── tests/                     # Unit, integration, performance
└── scripts/                   # Балансировка
```

### Makefile команды

Я использую только Makefile для управления проектом:

```makefile
make build          # Собрать обе версии
make run            # Запустить GUI версию
make run-headless   # Запустить headless версию
make test           # Все тесты (unit + integration)
make test-perf      # Тесты производительности
make bench          # Бенчмарки
make fmt            # Форматирование кода
make lint           # Линтер
make simulate       # Headless симуляция для балансировки
make profile        # Профилирование производительности
```

### Животные и поведение

#### Заяц (травоядное)
- Размер: радиус 5 единиц
- Скорость: 20 единиц/сек
- Здоровье: 50 хитов
- Поведение:
  - При голоде < 70%: ищет ближайшую траву
  - При виде волка в радиусе 50: убегает
  - При сытости > 80%: может размножаться

#### Волк (хищник)
- Размер: радиус 10 единиц
- Скорость: 30 единиц/сек при охоте
- Здоровье: 100 хитов
- Поведение:
  - При голоде < 60%: охотится на зайцев
  - Поедание зайца восстанавливает 50% сытости

### Механики симуляции

#### Голод
- Уменьшается на 1% каждые 5 секунд
- При 0% животное теряет здоровье (1 хит/сек)
- Влияет на скорость:
  - 0-20%: скорость x0.5
  - 80-100%: скорость x0.8

#### Размножение
- Требования: сытость > 80%, здоровье > 70%, партнер рядом
- Детёныши: 50% размера родителей, растут 1 минуту

#### Трава
- Рост: +1 единица каждые 2 секунды до максимума 100
- Поедание: заяц съедает 10 единиц за секунду
- Покрытие: 70% карты изначально

### Мир

- Размер: 50x50 тайлов (1 тайл = 32 пикселя)
- Водоёмы: 2-3 круглых озера
- Кусты: препятствия для движения
- Детерминированная генерация по seed

### Оптимизация производительности

#### Spatial Grid для поиска соседей
```go
type SpatialGrid struct {
    cellSize float32
    cells map[uint64][]EntityID
    queryBuffer [MAX_NEARBY]EntityID  // Без аллокаций
}
```

#### Object Pooling
```go
var vector2Pool = &sync.Pool{
    New: func() interface{} { return &Vec2{} },
}
```

### Графика и UI

#### Изометрическая проекция
```go
// Преобразование координат
screen_x = (world_x - world_y) * TILE_WIDTH/2
screen_y = (world_x + world_y) * TILE_HEIGHT/4
```

#### UI элементы
- Информация о животном при клике
- Глобальная статистика популяций
- Управление временем (пауза, x1, x2, x5)
- Дебаг режим (F3): границы, векторы движения, ID

### Балансировка экосистемы

#### Энергетический баланс
```
Солнце (1000) → Трава (100) → Зайцы (10) → Волки (1)
```

#### Целевые метрики
- 20-30 зайцев + 2-3 волка = стабильная популяция
- 10 минут симуляции без вымирания
- 100 животных = 60 FPS

### Тестирование

#### Типы тестов
- Unit тесты: каждая система отдельно
- Integration тесты: взаимодействие систем
- Performance тесты: 1000 животных
- Balance тесты: устойчивость экосистемы

#### Стратегия Test-Driven Debug
Я всегда создаю тест перед исправлением бага:
1. Создаю тест, который ловит баг
2. Исправляю код
3. Проверяю, что тест проходит
4. Запускаю все связанные тесты

### Важные константы

```go
const (
    MAX_ENTITIES = 1000
    WORLD_SIZE = 50
    TILE_SIZE = 32
    FIXED_TIMESTEP = 1.0/60.0
    
    RABBIT_RADIUS = 5
    RABBIT_SPEED = 20
    RABBIT_MAX_HEALTH = 50
    
    WOLF_RADIUS = 10
    WOLF_SPEED = 30
    WOLF_MAX_HEALTH = 100
    
    VISION_RANGE_RABBIT = 50
    VISION_RANGE_WOLF = 100
)
```

### Зависимости

- Go модуль: github.com/aiseeq/savanna
- GUI библиотека: github.com/hajimehoshi/ebiten/v2
- Конфигурация: gopkg.in/yaml.v3
- Тестирование: стандартная библиотека Go

### Чек-лист готовности MVP

- [ ] Мир 50x50 с травой
- [ ] Зайцы и волки с базовым поведением  
- [ ] Система питания (трава → зайцы → волки)
- [ ] Устойчивая экосистема
- [ ] GUI с изометрической графикой
- [ ] Headless режим для тестов
- [ ] 60 FPS при 100 животных
- [ ] Все тесты проходят
- [ ] Детерминированность симуляции
