### **План работ по стабилизации и балансировке симулятора Savanna**

**Цель:** Превратить текущую хаотичную симуляцию в стабильную, предсказуемую и легко балансируемую экосистему. Результатом должен стать играбельный MVP, в котором животные ведут себя адекватно.

**Ключевые принципы для Claude:**
1.  **Одна задача за раз:** Выполняй каждый пункт плана как отдельную, изолированную задачу.
2.  **Тесты — обязательны:** Каждый рефакторинг или изменение логики должны сопровождаться тестами, проверяющими новую функциональность.
3.  **Централизация констант:** Никаких магических чисел. Все параметры баланса должны быть в одном файле.
4.  **Детерминизм:** Всегда используй `world.GetRNG()` для случайных событий, избегай итераций по `map`.

---

### **ЭТАП 1: ФУНДАМЕНТ И НАБЛЮДАЕМОСТЬ (OBSERVABILITY)**

*Цель этого этапа — перестать работать вслепую. Мы создадим инструменты для понимания происходящего в симуляции и централизуем управление балансом.*

#### **ЗАДАЧА 1.1: Централизация игрового баланса**

**Промпт для Claude Code:**

> Создай файл `internal/simulation/game_balance.go`. В этом файле размести ВСЕ константы, влияющие на игровой баланс. Раздели их на секции с помощью комментариев.
>
> **КРИТИЧЕСКИ ВАЖНО:** Все единицы измерения расстояний (радиус, дальность видения) должны быть в **ТАЙЛАХ**, а не в пикселях. Физическая ширина тайла равна `1.0`. Скорость измеряется в **тайлах в секунду**.
>
> Создай следующие константы:
>
> 1.  **Размеры (в тайлах):**
>     *   `RabbitBaseRadius = 0.5`
>     *   `WolfBaseRadius = 0.75`
>     *   `CollisionRadiusMultiplier = 1.0` (Радиус коллизий = базовый радиус)
>
> 2.  **Дальность видения (множители от базового радиуса):**
>     *   `RabbitVisionMultiplier = 6.0` (Заяц видит на 3.0 тайла)
>     *   `WolfVisionMultiplier = 6.7` (Волк видит на ~5.0 тайлов)
>
> 3.  **Дальность атаки (множитель от базового радиуса):**
>     *   `WolfAttackRangeMultiplier = 1.2` (Атака чуть дальше своего радиуса)
>
> 4.  **Скорости (в тайлах/секунду):**
>     *   `RabbitBaseSpeed = 0.6`
>     *   `WolfBaseSpeed = 1.0`
>
> 5.  **Параметры голода:**
>     *   `RabbitHungerThreshold = 90.0` (% голода, когда заяц ищет еду)
>     *   `WolfHungerThreshold = 60.0` (% голода, когда волк ищет еду)
>     *   `BaseHungerDecreaseRate = 2.0` (% в секунду)
>
> 6.  **Боевые параметры:**
>     *   `WolfAttackDamage = 35`
>     *   `RabbitMaxHealth = 50`
>     *   `WolfMaxHealth = 100`

---

#### **ЗАДАЧА 1.2: Унификация создания животных (Фабрика)**

**Промпт для Claude Code:**

> Проведи рефакторинг создания животных. Создай файл `internal/simulation/animal_factory.go`.
>
> 1.  Создай в нем единую функцию `CreateAnimal(world *core.World, animalType core.AnimalType, x, y float32) core.EntityID`.
> 2.  Эта функция должна использовать **ТОЛЬКО** константы из `game_balance.go` для установки всех параметров (скорость, здоровье, радиусы, поведение).
> 3.  **Важно:** Функция должна правильно конвертировать размеры из ТАЙЛОВ (из `game_balance.go`) в ПИКСЕЛИ для компонента `core.Size`, умножая на константу `constants.TileSizePixels`.
> 4.  Создай `animal_config_factory.go` для генерации `core.AnimalConfig` на основе типа животного и констант баланса. `CreateAnimal` должна использовать эту фабрику.
> 5.  Замени все старые вызовы создания животных в коде на новую фабрику.
> 6.  Напиши юнит-тест `animal_factory_test.go`, который проверяет, что у созданных зайца и волка правильно установлены все параметры из `game_balance.go`.

---

#### **ЗАДАЧА 1.3: Создание Headless-отладчика**

**Промпт для Claude Code:**

> Создай новый исполняемый файл `cmd/debug_eating_system/main.go`. Это будет консольное приложение для отладки симуляции без GUI.
>
> 1.  В `main()` создай мир и все системы точно так же, как в GUI-версии.
> 2.  Запусти симуляцию на 720 тиков (12 секунд при 60 TPS).
> 3.  Каждые 60 тиков (каждую секунду) выводи в консоль следующую информацию:
>     *   Текущий тик и секунда.
>     *   Количество живых зайцев и волков.
>     *   Количество трупов на карте.
>     *   Количество волков в состоянии атаки и в состоянии поедания.
>     *   Для каждого волка: его ID, голод, здоровье и текущее состояние (блуждает, охотится, ест).
> 4.  Добавь соответствующую цель `run-debug-eating` в `Makefile`.

---

#### **ЗАДАЧА 1.4: Исправление системы движения**

**Промпт для Claude Code:**

> Открой `internal/simulation/movement.go`. Сейчас система, скорее всего, неверно работает со скоростями.
>
> 1.  Убедись, что `MovementSystem` получает `Velocity` в **тайлах/секунду** из других систем (например, `BehaviorSystem`).
> 2.  Внутри `updatePositions` **обязательно** конвертируй скорость из **тайлов/сек** в **пиксели/сек** перед обновлением `Position`. Для этого используй `constants.TilesToPixels()`.
> 3.  Напиши юнит-тест `speed_verification_test.go`, который:
>     *   Создает животное с базовой скоростью `1.0 тайл/сек`.
>     *   Симулирует его движение на 1 секунду.
>     *   Проверяет, что животное переместилось ровно на `32` пикселя.

---

### **ЭТАП 2: СТАБИЛИЗАЦИЯ ОСНОВНОЙ ЛОГИКИ**

*Цель: Исправить ключевые механики, которые вызывают хаос. Мы переработаем поведение и систему питания, сделав их предсказуемыми и управляемыми.*

#### **ЗАДАЧА 2.1: Рефакторинг поведения (SOLID)**

**Промпт для Claude Code:**

> Проведи рефакторинг `AnimalBehaviorSystem`, чтобы он полностью управлялся компонентами, а не `if animalType == ...`.
>
> 1.  Создай в `core/components.go` компонент `AnimalConfig`, который хранит все параметры из `game_balance.go` (MaxHealth, BaseSpeed, VisionRange, HungerThreshold и т.д.).
> 2.  Обнови `animal_factory.go`, чтобы он добавлял этот компонент каждому животному.
> 3.  В `AnimalBehaviorSystem` получай все пороги и дальности (`HungerThreshold`, `VisionRange`) из компонента `AnimalConfig`, а не из констант.
> 4.  Удали все проверки `if animalType == core.TypeRabbit` или `core.TypeWolf`. Логика должна работать для любого животного с `BehaviorType` (травоядное/хищник) и `AnimalConfig`.
> 5.  Напиши тест, который создает кастомное травоядное с большим радиусом зрения и проверяет, что оно находит траву на этом расстоянии.

---

#### **ЗАДАЧА 2.2: Переработка системы питания (Discrete Eating)**

**Промпт для Claude Code:**

> Текущая система питания, вероятно, работает непрерывно и нестабильно. Реализуй **дискретную систему питания**, основанную на анимации.
>
> 1.  Раздели логику на две системы:
>     *   `GrassSearchSystem`: отвечает ТОЛЬКО за поиск травы. Если голодное травоядное стоит на траве, эта система добавляет ему компонент `EatingState{Target: 0}`.
>     *   `GrassEatingSystem`: эта система дает сытость. Она проверяет животных с `EatingState`. Сытость дается **ТОЛЬКО** в тот момент, когда кадр анимации `AnimEat` переключается с 0 на 1.
> 2.  **Критическая логика в `GrassEatingSystem`:**
>     ```go
>     // (псевдокод)
>     prevFrame := world.GetPreviousAnimationFrame(entity) // нужно реализовать хранение прошлого кадра
>     currentFrame := world.GetAnimation(entity).Frame
>     if prevFrame == 0 && currentFrame == 1 {
>         // Съедаем N травы, даем M сытости
>         processGrassEatingTick()
>     }
>     ```
> 3.  Обнови `main.go` и `debug_eating_system`, чтобы системы вызывались в правильном порядке: `GrassSearchSystem` -> `GrassEatingSystem` -> `BehaviorSystem`.
> 4.  Напиши интеграционный тест `eating_frame_validation_test.go`, который покадрово проверяет, что сытость дается **только** при переходе с 0 на 1 кадр и не дается на других кадрах.

---

### **ЭТАП 3: ИСПРАВЛЕНИЕ ПОБОЧНЫХ ЭФФЕКТОВ И БАЛАНСИРОВКА**

*Цель: устранить оставшиеся аномалии в поведении и провести первичную балансировку на основе новых, стабильных систем.*

#### **ЗАДАЧА 3.1: Решение проблемы "Кластеризация в углах"**

**Промпт для Claude Code:**

> Проблема: зайцы, убегая от волков, забиваются в углы и там остаются.
>
> 1.  Проанализируй `MovementSystem` и `AnimalBehaviorSystem`. Вероятная причина — логика побега просто инвертирует вектор до хищника, что направляет зайца точно в угол.
> 2.  Исправь логику побега. Введи дополнительный вектор "отталкивания от границ". Если заяц находится близко к границе (например, < 5% от ширины мира), к его вектору движения должен добавляться вектор, направленный от этой границы к центру карты.
> 3.  Напиши интеграционный тест `corner_clustering_behavior_test.go`, который:
>     *   Создает мир 50x38.
>     *   Размещает волка в центре.
>     *   Размещает зайца рядом с волком, но ближе к углу.
>     *   Симулирует 10 секунд.
>     *   Проверяет, что финальная позиция зайца НЕ находится в углу карты.

---

#### **ЗАДАЧА 3.2: Финальная балансировка и проверка**

**Промпт для Claude Code:**

> Теперь, когда все системы работают предсказуемо, проведи финальную балансировку.
>
> 1.  Открой `internal/simulation/game_balance.go`.
> 2.  Установи следующие значения, чтобы животные были хорошо видны в дебаге, но не гигантские:
>     *   `RabbitBaseRadius = 0.5`
>     *   `WolfBaseRadius = 0.75`
>     *   `RabbitBaseSpeed = 3.0`
>     *   `WolfBaseSpeed = 4.0`
>     *   `RabbitVisionMultiplier = 6.0` // -> 3.0 тайла
>     *   `WolfVisionMultiplier = 6.7` // -> ~5.0 тайлов
>     *   `WolfAttackRangeMultiplier = 1.2` // -> 0.9 тайла
> 3.  Запусти отладчик `make run-debug-eating`.
> 4.  Наблюдай за симуляцией. Цель: в течение 10-12 секунд волки должны успеть убить хотя бы одного зайца, но не всех. Зайцы не должны вымирать от голода.
> 5.  Если баланс нарушен, аккуратно скорректируй **только** значения в `game_balance.go` и повтори тест.
> 6.  Когда симуляция будет выглядеть стабильной, закоммить финальные значения.

---

### **Ожидаемый результат**

После выполнения этого плана кодовая база будет иметь:
-   **Стабильную, предсказуемую симуляцию.**
-   **Централизованный файл баланса**, позволяющий легко настраивать игру.
-   **Надежные тесты**, проверяющие реальное поведение, а не моки.
-   **Улучшенную архитектуру**, соответствующую SOLID принципам.
-   **Решенные проблемы** со скоростью, питанием и кластеризацией.
