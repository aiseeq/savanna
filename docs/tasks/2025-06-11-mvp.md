# План агентной разработки: Симулятор экосистемы саванны

## Описание проекта

### Концепция
Игра-песочница с симуляцией экосистемы африканской саванны. Игрок наблюдает за живой экосистемой и может создавать собственные виды животных, экспериментируя с их параметрами. Цель - создать устойчивые виды, которые смогут выжить и процветать в экосистеме.

### Ключевые особенности
- **Детерминированная симуляция**: один seed = одинаковый результат
- **Изометрическая графика**: стиль StarCraft 1
- **Масштабируемость**: от десятков до тысяч животных
- **Энергетический баланс**: солнце → трава → травоядные → хищники
- **Реалистичное поведение**: голод, жажда, размножение, смерть

### MVP функциональность
- Статичная карта с растущей травой
- Два вида животных: зайцы (травоядные) и волки (хищники)
- Базовые потребности: голод и здоровье
- Простое поведение: поиск еды, охота, размножение
- Устойчивая экосистема без вмешательства игрока

## Детальные требования

### Животные и их поведение

#### Заяц (травоядное)
- **Размер**: малый (радиус ~5 единиц)
- **Скорость**: средняя (20 единиц/сек)
- **Здоровье**: 50 хитов
- **Поведение**:
  - При голоде < 70%: ищет ближайшую траву
  - При виде волка в радиусе 50: убегает в противоположном направлении
  - При сытости > 80% и безопасности: может размножаться
  - Ест траву при контакте (10 единиц травы = 20% сытости)

#### Волк (хищник)
- **Размер**: средний (радиус ~10 единиц)
- **Скорость**: быстрая (30 единиц/сек при охоте)
- **Здоровье**: 100 хитов
- **Поведение**:
  - При голоде < 60%: ищет ближайшего зайца
  - Преследует выбранную жертву до поимки
  - Атакует при контакте (убивает зайца за 1-2 удара)
  - Поедание зайца восстанавливает 50% сытости

### Механики

#### Голод
- Уменьшается на 1% каждые 5 секунд
- При 0% животное начинает терять здоровье (1 хит/сек)
- Влияет на скорость: 
  - 0-20%: скорость x0.5
  - 80-100%: скорость x0.8 (переедание)

#### Здоровье  
- Восстанавливается при сытости > 50%: +1 хит/10 сек
- Влияние на параметры: при 50% здоровья все параметры x0.7

#### Движение
- Векторная система притяжения/отталкивания
- Прямое движение при отсутствии препятствий
- Обход препятствий простым отклонением
- Инерции нет, повороты мгновенные

#### Размножение
- Требования: сытость > 80%, здоровье > 70%, рядом особь того же вида
- Появляется 1-2 детёныша рядом с родителями
- Детёныши имеют 50% размера и параметров взрослых

### Мир и окружение

#### Карта (MVP)
- Размер: 50x50 тайлов (1 тайл = 32 пикселя)
- Плоская местность с травой
- Несколько водоёмов (круглые озёра)
- Группы кустов (препятствия и укрытия)

#### Трава
- Начальное покрытие: 70% карты
- Рост: +1 единица каждые 2 секунды до максимума 100
- Поедание: заяц съедает 10 единиц за 1 секунду контакта
- Не растёт на воде и в радиусе 1 тайл от воды

### Технические детали

#### Константы производительности
```go
const (
    MAX_ENTITIES = 1000
    WORLD_SIZE = 50
    TILE_SIZE = 32
    FIXED_TIMESTEP = 1.0/60.0  // 60 TPS
)
```

#### Детерминированность
- Фиксированный timestep
- Seed-based генерация
- Стабильная сортировка сущностей
- Никаких недетерминированных map итераций

## Структура проекта

```
savanna/
├── Makefile                    # Единая точка входа для всех команд
├── go.mod                      # Go модуль
├── go.sum
├── README.md                   # Документация проекта
├── config/
│   ├── config.go              # Конфигурация игры
│   └── config.yaml            # Дефолтные настройки
├── cmd/
│   ├── game/                  # GUI версия
│   │   └── main.go
│   └── headless/              # Консольная версия для тестов
│       └── main.go
├── internal/
│   ├── core/                  # Ядро симуляции
│   │   ├── world.go          # Основной мир
│   │   ├── entity.go         # ECS базовые типы
│   │   ├── components.go     # Компоненты ECS
│   │   └── systems.go        # Системы ECS
│   ├── simulation/           # Логика симуляции
│   │   ├── animal.go         # Поведение животных
│   │   ├── vegetation.go     # Система растительности
│   │   ├── movement.go       # Система движения
│   │   └── feeding.go        # Система питания
│   ├── physics/              # Физика и коллизии
│   │   ├── vector.go         # Векторная математика
│   │   ├── collision.go      # Детекция коллизий
│   │   └── spatial.go        # Пространственная сетка
│   ├── rendering/            # Отрисовка (только для GUI)
│   │   ├── renderer.go       # Основной рендерер
│   │   ├── camera.go         # Камера и масштаб
│   │   └── sprites.go        # Загрузка спрайтов
│   └── generator/            # Генерация мира
│       ├── terrain.go        # Генерация ландшафта
│       └── population.go     # Начальная популяция
├── assets/                    # Ресурсы игры
│   ├── sprites/              # Спрайты животных
│   │   ├── rabbit/           # idle.png, walk.png, eat.png...
│   │   └── wolf/             # idle.png, walk.png, attack.png...
│   └── terrain/              # Спрайты местности
├── tests/
│   ├── unit/                 # Unit тесты
│   ├── integration/          # Интеграционные тесты
│   ├── performance/          # Тесты производительности
│   └── fixtures/             # Тестовые данные
├── scripts/
│   ├── generate_sprites.md   # Инструкции для генерации
│   └── balance_test.go       # Скрипты балансировки
└── docs/
    ├── architecture.md       # Архитектура проекта
    └── llm-prompts/         # Сохранённые промпты

```

## Makefile команды

```makefile
# Основные команды
make build          # Собрать обе версии
make run            # Запустить GUI версию
make run-headless   # Запустить headless версию
make test           # Все тесты
make test-unit      # Только unit тесты
make test-perf      # Тесты производительности
make bench          # Бенчмарки

# Разработка
make fmt            # Форматирование кода
make lint           # Линтер
make generate       # Генерация кода
make profile        # Запуск с профилированием

# Симуляция
make simulate       # Запуск headless симуляции
make balance        # Тесты баланса
```

## Этапы разработки

### Этап 0: Инициализация проекта (30 мин)
**Промпт для Claude Code:**
```
Создай базовую структуру Go проекта для игры-симулятора экосистемы:
1. Инициализируй go.mod с именем github.com/aiseeq/savanna
2. Создай структуру папок согласно плану
3. Создай Makefile с базовыми командами (build, test, run)
4. Добавь .gitignore для Go проектов
5. Создай заглушки main.go для cmd/game и cmd/headless
6. Настрой go.mod с зависимостями: github.com/hajimehoshi/ebiten/v2
```

**Результат:** Компилируемый проект с базовой структурой

### Этап 1: Математика и физика (2 часа)
**Промпт для Claude Code:**
```
Реализуй базовую математику для 2D симуляции:
1. internal/physics/vector.go - Vec2 с операциями (add, sub, mul, normalize, distance)
2. internal/physics/collision.go - проверка коллизий круг-круг, круг-прямоугольник
3. internal/physics/spatial.go - пространственная сетка для быстрого поиска соседей
4. Покрой всё unit тестами с table-driven подходом
5. Добавь бенчмарки для критичных операций
```

**Результат:** Математическая база с тестами

### Этап 2: ECS архитектура (3 часа)
**Промпт для Claude Code:**
```
Создай простую но эффективную ECS систему для симулятора:

1. internal/core/entity.go:
   ```go
   type EntityID uint16  // До 65535 сущностей
   
   type EntityManager struct {
       nextID EntityID
       freeIDs []EntityID  // Переиспользование ID
       alive [MAX_ENTITIES]bool
   }
   
   // Методы: CreateEntity(), DestroyEntity(id), IsAlive(id)
   ```

2. internal/core/components.go - компоненты как простые структуры:
   ```go
   type Position struct { X, Y float32 }
   type Velocity struct { X, Y float32 }
   type Health struct { Current, Max int16 }
   type Hunger struct { Value float32 }  // 0-100
   type Age struct { Seconds float32 }
   
   type AnimalType uint8
   const (
       TypeNone AnimalType = iota
       TypeRabbit
       TypeWolf
   )
   
   type Size struct { Radius float32 }
   type Speed struct { Base, Current float32 }
   ```

3. internal/core/world.go - Arrays of Structs для оптимальной производительности:
   ```go
   type World struct {
       // Entity management
       entities EntityManager
       
       // Components - индексируются по EntityID
       positions [MAX_ENTITIES]Position
       velocities [MAX_ENTITIES]Velocity
       healths [MAX_ENTITIES]Health
       hungers [MAX_ENTITIES]Hunger
       ages [MAX_ENTITIES]Age
       types [MAX_ENTITIES]AnimalType
       sizes [MAX_ENTITIES]Size
       speeds [MAX_ENTITIES]Speed
       
       // Битовые маски для быстрой проверки наличия компонентов
       hasPosition [MAX_ENTITIES/64]uint64
       hasVelocity [MAX_ENTITIES/64]uint64
       // и т.д.
       
       // Вспомогательные данные
       time float32  // Общее время симуляции
       rng *rand.Rand  // Детерминированный генератор
   }
   ```

4. Методы для работы с компонентами:
   - AddComponent[T](entity, component) - generic метод
   - GetComponent[T](entity) (T, bool)
   - RemoveComponent[T](entity)
   - HasComponent[T](entity) bool
   
   Используй битовые операции для hasComponent масок

5. Системы запросов:
   ```go
   // Итератор по сущностям с определёнными компонентами
   func (w *World) ForEachWith(components ComponentMask, fn func(EntityID))
   
   // Пример использования:
   w.ForEachWith(MaskPosition|MaskVelocity, func(e EntityID) {
       w.positions[e].X += w.velocities[e].X * dt
   })
   ```

6. Тесты:
   - Создание/удаление 1000 сущностей
   - Добавление/удаление компонентов
   - Проверка переиспользования ID
   - Бенчмарк итерации по 1000 сущностям
   - Проверка что нет утечек памяти при удалении
```

**Результат:** Высокопроизводительная ECS система без аллокаций в runtime

### Этап 3: Базовая симуляция (4 часа)
**Промпт для Claude Code:**
```
Реализуй основной цикл симуляции для экосистемы саванны:

1. internal/core/systems.go - интерфейс System с методом Update(world, dt)

2. internal/simulation/movement.go - MovementSystem:
   - Обновление позиций по velocity
   - Ограничение границами мира (50x50 тайлов)
   - Мягкое расталкивание при коллизиях (круги)

3. internal/simulation/animal.go - базовое поведение животных:
   
   Константы:
   - RABBIT_RADIUS = 5, RABBIT_SPEED = 20
   - WOLF_RADIUS = 10, WOLF_SPEED = 30
   - RABBIT_MAX_HEALTH = 50, WOLF_MAX_HEALTH = 100
   - VISION_RANGE_RABBIT = 50, VISION_RANGE_WOLF = 100
   
   Поведение зайца:
   - Если видит волка: velocity = normalize(rabbit_pos - wolf_pos) * RABBIT_SPEED
   - Иначе: случайное блуждание (меняет направление каждые 2-5 сек)
   
   Поведение волка:
   - Если голоден (hunger < 60): ищет ближайшего зайца в VISION_RANGE_WOLF
   - Преследует: velocity = normalize(prey_pos - wolf_pos) * WOLF_SPEED
   - Иначе: случайное блуждание с WOLF_SPEED * 0.5

4. internal/simulation/feeding.go - система голода:
   - Hunger уменьшается на 0.2 каждый Update (1% за 5 сек при 60 TPS)
   - При hunger = 0: health -= 1 каждую секунду
   - При hunger < 20: скорость x0.5
   - При hunger > 80: скорость x0.8

5. cmd/headless/main.go:
   - Создать мир 50x50
   - Разместить 20 зайцев и 3 волка случайно
   - Каждую секунду выводить: кол-во живых зайцев/волков
   - Детерминированный random с фиксированным seed

6. Интеграционный тест:
   - 10 зайцев, 2 волка на поле 20x20
   - Проверить что за 30 секунд хотя бы 1 заяц съеден
   - Проверить детерминированность (2 запуска = одинаковый результат)
```

**Результат:** Работающая headless симуляция с базовым поведением

### Этап 4: Генерация мира (2 часа)
**Промпт для Claude Code:**
```
Добавь детерминированную генерацию карты саванны:

1. internal/generator/terrain.go:
   
   Структура мира:
   type Terrain struct {
       tiles [WORLD_SIZE][WORLD_SIZE]TileType
       grass [WORLD_SIZE][WORLD_SIZE]float32  // 0-100
   }
   
   Генерация:
   - Базовый слой: вся карта - трава
   - Водоёмы: 2-3 круглых озера радиусом 3-5 тайлов
   - Вокруг воды: полоса влажной земли (1 тайл) где трава растёт быстрее
   - Кусты: 5-10 групп по 3-7 кустов (препятствия для движения)
   - Начальная трава: 50-100 единиц на 70% тайлов, 0 на воде
   
2. internal/generator/population.go:
   
   Размещение животных:
   - Входные параметры: количество зайцев, волков
   - Зайцы: группами по 2-4 особи (семьи)
   - Волки: поодиночке, минимум в 20 тайлах друг от друга
   - Не размещать на воде и кустах
   - Начальные параметры: hunger=80%, health=100%

3. config/config.go и config.yaml:
   ```yaml
   world:
     size: 50
     seed: 42
   
   terrain:
     water_bodies: 3
     water_radius_min: 3
     water_radius_max: 5
     bush_clusters: 7
     bush_per_cluster: 5
   
   population:
     rabbits: 30
     wolves: 3
     rabbit_group_size: 3
     min_wolf_distance: 20
   ```

4. Детерминированность:
   - Используй rand.NewSource(seed) для каждого генератора
   - Генерация в фиксированном порядке: terrain → vegetation → animals
   - Сохранение/загрузка seed для воспроизведения

5. Тесты:
   - Генерация с одним seed 10 раз = идентичные карты
   - Проверка что животные не в воде/кустах
   - Валидация минимальных расстояний
```

**Результат:** Генерируемый мир с контролируемыми параметрами

### Этап 5: Растительность и питание (3 часа)
**Промпт для Claude Code:**
```
Реализуй полную систему питания для экосистемы:

1. internal/simulation/vegetation.go:
   - Компонент Grass: amount float32 (0-100)
   - GrassSystem: 
     * Рост: +0.5 каждый Update если amount < 100
     * Не растёт на воде и в радиусе 1 тайла от воды
   - Сетка травы 50x50 (по тайлам)
   - Начальное заполнение: 70% тайлов с grass = 50-100

2. Обнови internal/simulation/feeding.go:
   
   Питание зайца:
   - При контакте с тайлом травы (amount > 10):
     * grass.amount -= 10 за секунду
     * rabbit.hunger += 20
   - Максимум hunger = 100
   
   Охота волка:
   - При контакте с зайцем: наносит 30 урона
   - Если заяц умер: wolf.hunger += 50
   - Труп исчезает сразу (в будущем - оставлять для падальщиков)

3. internal/simulation/animal.go - обнови поведение:
   
   Приоритеты зайца:
   1. Если видит волка - убегать (всегда)
   2. Если hunger < 70 - идти к ближайшей траве
   3. Если сыт - случайное движение или отдых
   
   Приоритеты волка:
   1. Если hunger < 60 - охотиться на ближайшего зайца
   2. Если сыт - патрулировать территорию

4. Баланс экосистемы:
   - 1 тайл травы (100 единиц) должен кормить зайца ~50 секунд
   - 1 заяц должен кормить волка ~100 секунд
   - При 30 зайцах и 3 волках популяция должна быть стабильной

5. Тесты баланса:
   - Запустить симуляцию на 10 минут
   - Проверить что популяции не вымерли
   - Проверить что трава не закончилась
   - Вывести графики популяций
```

**Результат:** Замкнутая пищевая цепь с устойчивым балансом

### Этап 6: Графический интерфейс - Подготовка (1 час)

**Инструкции для оператора:**
```markdown
# Генерация спрайтов

Необходимо создать базовые спрайты для MVP. Используй любой доступный AI генератор изображений.

## Требования к спрайтам:
- Размер: 32x32 пикселя
- Формат: PNG с прозрачным фоном
- Стиль: простой, читаемый при масштабировании
- Изометрическая проекция (вид 3/4)

## Необходимые спрайты:

### Заяц (assets/sprites/rabbit/)
- idle.png - стоит
- walk_1.png, walk_2.png - анимация ходьбы
- eat.png - ест
- sleep.png - спит
- dead.png - мёртв

### Волк (assets/sprites/wolf/)
- idle.png - стоит
- walk_1.png, walk_2.png - анимация ходьбы  
- run_1.png, run_2.png - бег
- attack.png - атакует
- eat.png - ест
- dead.png - мёртв

### Terrain (assets/terrain/)
- grass.png - тайл травы 32x32
- water.png - тайл воды 32x32
- bush.png - куст 32x32

## Цветовая схема:
- Заяц: коричневый/серый
- Волк: серый/тёмный
- Трава: жёлто-зелёная (саванна)
- Вода: голубая
- Кусты: тёмно-зелёные

Сохрани все спрайты в соответствующие папки.
```

**Промпт для Claude Code после генерации спрайтов:**
```
Создай систему загрузки и управления спрайтами:
1. internal/rendering/sprites.go:
   - LoadSprites() - загрузка всех спрайтов
   - GetSprite(entity, state) - получение нужного спрайта
   - Кеширование загруженных изображений
2. Обработка ошибок если спрайты не найдены
3. Заглушки (цветные квадраты) для отсутствующих спрайтов
```

### Этап 7: Базовый рендеринг (4 часа)
**Промпт для Claude Code:**
```
Реализуй графическую версию игры в изометрическом стиле:

1. internal/rendering/renderer.go:
   
   Порядок отрисовки (важно!):
   1. Тайлы местности (трава, вода)
   2. Кусты и препятствия
   3. Животные, отсортированные по Y (дальние сначала)
   
   Преобразование координат:
   - Мир: 50x50 тайлов, каждый 32x32 пикселя
   - Изометрия: screen_x = (world_x - world_y) * TILE_WIDTH/2
   - screen_y = (world_x + world_y) * TILE_HEIGHT/4
   
   Отрисовка животных:
   - Позиция в центре спрайта
   - Выбор спрайта по состоянию (idle/walk/eat/dead)
   - Плавное движение между тайлами

2. internal/rendering/camera.go:
   - Позиция камеры в мировых координатах
   - Zoom уровни: 0.5x, 1x, 2x, 4x
   - Ограничения камеры границами мира
   - Плавное движение (lerp)

3. cmd/game/main.go - Ebiten приложение:
   
   type Game struct {
       world *core.World
       renderer *rendering.Renderer
       camera *rendering.Camera
       lastUpdate time.Time
   }
   
   Update():
   - WASD - движение камеры (10 тайлов/сек)
   - Колесо мыши - zoom in/out
   - Обновление симуляции с FIXED_TIMESTEP
   - Накопление времени для стабильного FPS
   
   Draw():
   - Отрисовка только видимых тайлов (frustum culling)
   - Батчинг однотипных спрайтов
   - FPS счётчик в углу

4. Оптимизация:
   - Предзагрузка всех спрайтов
   - Повторное использование DrawImageOptions
   - Пропуск отрисовки за пределами экрана
   - Целевой FPS: 60 при 100 животных

5. Дебаг режим (F3):
   - Показать границы тайлов
   - Радиусы коллизий животных  
   - Векторы движения
   - ID сущностей
```

**Результат:** Играбельная версия с изометрической графикой

### Этап 8: UI и взаимодействие (3 часа)
**Промпт для Claude Code:**
```
Добавь интерфейс и базовые механики размножения:

1. Информация о животном при клике:
   
   internal/rendering/ui.go:
   - Определение клика по животному (с учётом изометрии)
   - Панель информации:
     * Тип (Заяц/Волк)
     * Здоровье: 45/50 HP
     * Сытость: 67%
     * Возраст: 2.5 минут
     * Состояние: "Ищет еду" / "Убегает" / "Охотится"
   - Подсветка выбранного животного

2. Глобальная статистика (правый верхний угол):
   - Зайцы: 24 (рождений: 5, смертей: 11)
   - Волки: 3 (рождений: 0, смертей: 0)
   - Общая биомасса травы: 4250
   - Время: 05:42
   - FPS: 60 / TPS: 60

3. Управление временем (клавиши 1-4 или UI кнопки):
   - Пауза (пробел)
   - x1 - нормальная скорость
   - x2 - ускорение
   - x5 - максимальное ускорение
   - При ускорении можно пропускать отрисовку кадров

4. Добавь базовое размножение:
   
   internal/simulation/breeding.go:
   - Проверка условий каждые 5 секунд:
     * Сытость > 80%
     * Здоровье > 70% 
     * Возраст > 1 минута
     * Партнёр того же вида в радиусе 10
   - Рождение 1-2 детёнышей (50% вероятность на 2)
   - Детёныши:
     * 50% размера родителей
     * Растут до полного размера за 1 минуту
     * Начальные hunger=50%, health=100%
   - Визуализация: сердечки над родителями 2 сек

5. Сохранение/загрузка (JSON):
   - F5 - быстрое сохранение в savegame.json
   - F9 - быстрая загрузка
   - Сохранять: позиции, параметры всех животных, состояние травы, время, seed

6. Расширенный дебаг режим (F3):
   - ID животных над спрайтами
   - Векторы движения (стрелки)
   - Радиусы обзора (полупрозрачные круги)
   - Сетка тайлов
   - Количество травы на тайле
```

**Результат:** Полноценный интерактивный интерфейс с размножением

### Этап 9: Балансировка и тесты (4 часа)
**Промпт для Claude Code:**
```
Создай систему для балансировки:
1. scripts/balance_test.go - автоматические тесты баланса:
   - Запуск 100 симуляций с разными параметрами
   - Проверка устойчивости популяций
   - Поиск оптимальных коэффициентов
2. cmd/headless/main.go - режим для массовых тестов:
   - Параметры через флаги командной строки
   - CSV вывод результатов
   - Режим ускоренной симуляции
3. tests/integration/ecosystem_test.go:
   - Тест на вымирание
   - Тест на перенаселение
   - Тест на стабильность
4. Makefile targets для автоматической балансировки
```

**Результат:** Сбалансированная экосистема

### Этап 10: Полировка MVP (2 часа)
**Промпт для Claude Code:**
```
Финальная полировка:
1. README.md с инструкциями по запуску
2. Дефолтный config.yaml с хорошим балансом
3. Обработка всех edge cases (выход за границы и т.д.)
4. Логирование важных событий
5. Проверка производительности (1000 животных = 60 FPS)
6. Финальный прогон всех тестов
7. Добавь комментарии к публичным функциям
```

**Результат:** Готовый к релизу MVP

## Формулы и коэффициенты

### Энергетический баланс
```
Солнечная энергия (условно 1000 единиц/сек на всю карту)
↓
Трава (КПД 10%): 100 единиц энергии/сек
↓
Зайцы (КПД 10%): 10 единиц энергии/сек  
↓
Волки (КПД 10%): 1 единица энергии/сек
```

### Метаболизм и потребление
- **Заяц**: тратит 0.2 энергии/сек (голод), получает 2.0 от травы
- **Волк**: тратит 0.1 энергии/сек (голод), получает 50 от зайца
- **Трава**: растёт +0.5/сек до максимума 100

### Детерминированность - критические моменты
1. **Никогда не используй**:
   - time.Now() для игровой логики
   - rand без фиксированного seed
   - итерацию по map (используй слайсы)
   - горутины в симуляции

2. **Всегда используй**:
   - Фиксированный timestep (1/60 сек)
   - Стабильную сортировку (sort.SliceStable)
   - Один глобальный rand с seed
   - Целочисленную или фиксированную арифметику где возможно

### Оптимизация - ключевые точки
```go
// Spatial hash для поиска соседей
type SpatialGrid struct {
    cellSize float32
    cells map[uint64][]EntityID  // key = (x/cellSize) << 32 | (y/cellSize)
    
    // Для избежания аллокаций
    queryBuffer [MAX_NEARBY]EntityID
}

// Добавление в сетку (вызывается при движении)
func (g *SpatialGrid) Update(id EntityID, oldX, oldY, newX, newY float32) {
    oldKey := g.getKey(oldX, oldY)
    newKey := g.getKey(newX, newY)
    
    if oldKey != newKey {
        g.removeFromCell(oldKey, id)
        g.addToCell(newKey, id)
    }
}

// Поиск соседей без аллокаций
func (g *SpatialGrid) FindNearby(x, y, radius float32) []EntityID {
    count := 0
    cellRadius := int(radius/g.cellSize) + 1
    
    centerI := int(x / g.cellSize)
    centerJ := int(y / g.cellSize)
    
    for di := -cellRadius; di <= cellRadius; di++ {
        for dj := -cellRadius; dj <= cellRadius; dj++ {
            key := g.getKey(float32((centerI+di)*int(g.cellSize)), 
                           float32((centerJ+dj)*int(g.cellSize)))
            
            for _, id := range g.cells[key] {
                // Точная проверка расстояния
                if distance(x, y, positions[id].X, positions[id].Y) <= radius {
                    g.queryBuffer[count] = id
                    count++
                    if count >= MAX_NEARBY { 
                        return g.queryBuffer[:count] 
                    }
                }
            }
        }
    }
    return g.queryBuffer[:count]
}

// Object pooling для частых аллокаций
var vector2Pool = &sync.Pool{
    New: func() interface{} { return &Vec2{} },
}

// SOA (Structure of Arrays) вместо AOS для компонентов
type Components struct {
    // Хорошо для кэша CPU - данные расположены последовательно
    positions [MAX_ENTITIES]Vec2    
    velocities [MAX_ENTITIES]Vec2
    
    // Плохо для кэша - разрозненные данные
    // entities [MAX_ENTITIES]Entity{pos, vel, health...}
}
```

## Дополнительные детали реализации

### Векторная система движения
```go
// Расчёт результирующего вектора движения
func CalculateMovement(animal EntityID, world *World) Vec2 {
    var result Vec2
    
    // 1. Отталкивание от угроз (приоритет)
    threats := FindThreatsInRadius(animal, VISION_RANGE)
    for _, threat := range threats {
        diff := animal.pos.Sub(threat.pos)
        weight := 1.0 - (diff.Length() / VISION_RANGE)
        result = result.Add(diff.Normalize().Mul(weight * THREAT_WEIGHT))
    }
    
    // 2. Притяжение к цели (еда)
    if animal.hunger < 70 {
        food := FindNearestFood(animal)
        if food != nil {
            diff := food.pos.Sub(animal.pos)
            result = result.Add(diff.Normalize().Mul(FOOD_WEIGHT))
        }
    }
    
    // 3. Случайное блуждание (если нет других стимулов)
    if result.Length() < 0.1 {
        result = RandomDirection().Mul(WANDER_WEIGHT)
    }
    
    return result.Normalize().Mul(animal.speed)
}
```

### Состояния животных (для выбора спрайтов)
```go
type AnimalState int
const (
    StateIdle AnimalState = iota
    StateWalking
    StateRunning  
    StateEating
    StateAttacking
    StateSleeping
    StateDead
)

func GetAnimalState(e EntityID, w *World) AnimalState {
    if w.healths[e] <= 0 { return StateDead }
    if w.velocities[e].Length() < 0.1 { return StateIdle }
    if w.velocities[e].Length() > WALK_SPEED { return StateRunning }
    if w.isEating[e] { return StateEating }
    return StateWalking
}
```

## Чек-лист готовности MVP

- [ ] Мир 50x50 с травой
- [ ] Зайцы и волки с базовым поведением
- [ ] Зайцы едят траву, волки едят зайцев
- [ ] Трава восстанавливается
- [ ] Устойчивая экосистема
- [ ] GUI с масштабированием
- [ ] Headless режим для тестов
- [ ] Все тесты проходят
- [ ] 60 FPS при 100 животных
- [ ] Документация

## Метрики успеха

1. **Производительность**: 1000 животных при 60 FPS
2. **Стабильность**: популяции не вымирают 10+ минут
3. **Детерминированность**: одинаковый seed = одинаковый результат
4. **Тестируемость**: 80%+ покрытие кода
5. **Модульность**: легко добавить нового зверя

## Важные принципы для промптов

1. **Всегда проси тесты** - каждая функция должна быть покрыта
2. **Фиксированные размеры** - используй константы MAX_ENTITIES
3. **Никаких аллокаций в циклах** - переиспользуй буферы
4. **Детерминированность** - никаких map итераций
5. **Профилирование** - проси добавлять pprof точки

## Советы для работы с Claude Code

### Структура промптов
1. **Начинай с контекста**: "Мы разрабатываем симулятор экосистемы саванны..."
2. **Указывай файлы явно**: "Создай файл internal/physics/vector.go"
3. **Проси тесты сразу**: "...и напиши unit тесты в vector_test.go"
4. **Уточняй производительность**: "Функция будет вызываться 1000 раз за кадр"

### Частые проблемы и решения
- **Claude забывает константы**: держи файл config/constants.go и напоминай о нём
- **Неоптимальный код**: явно проси избегать аллокаций в циклах
- **Недетерминированность**: проверяй каждый use case с rand и map
- **Путаница с координатами**: рисуй схемы в комментариях

### Отладка производительности
```bash
# Встрой в Makefile
profile:
    go run -cpuprofile=cpu.prof cmd/headless/main.go -duration=30s
    go tool pprof -http=:8080 cpu.prof

# Добавь в main.go
import _ "net/http/pprof"
go func() { http.ListenAndServe("localhost:6060", nil) }()
```

## Финальные напоминания

1. **MVP first**: не усложняй! Сначала рабочая версия, потом фичи
2. **Тесты важны**: каждый этап должен завершаться зелёными тестами  
3. **Сохраняй промпты**: для статьи на Хабр это золото
4. **Коммить часто**: после каждого успешного этапа
5. **Профилируй рано**: проблемы производительности сложно фиксить потом

## Ожидаемые метрики MVP
- 20-30 зайцев + 2-3 волка = стабильная популяция
- 100 животных = 60 FPS на среднем ПК
- 10 минут симуляции без вымирания
- Детерминированность: diff между прогонами = 0

## Команда для старта
```bash
# Этап 0: Инициализация
mkdir savanna && cd savanna
# Далее копируй промпт из Этапа 0 в Claude Code
```

Удачи в разработке! 🐰🐺🌿